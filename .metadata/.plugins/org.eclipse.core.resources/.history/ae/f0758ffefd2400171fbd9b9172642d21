/*
 * os.h
 *
 *  Created on: Apr 18, 2017
 *      Author: warlo
 */

#ifndef XV6CPP_OS_H_
#define XV6CPP_OS_H_

#include <cstdint>
#include <sys\queue.h>
#include <algorithm>
//#include <macros.h>
#include <cassert>

namespace xv6 {
// helper functions for enums
// cast enum

template<typename E>
constexpr static inline typename std::underlying_type<E>::type cast_underlying(const E val) {
	return static_cast<typename std::underlying_type<E>::type>(val);
}
template<typename E>
constexpr static inline auto combine_flags(const E left) {
	return static_cast<E>(cast_underlying(left));
}
template<typename E, typename... Args>
constexpr static inline auto combine_flags(const E left,Args&&... args) {
	return static_cast<E>(combine_flags(left) | combine_flags(combine_flags(std::forward<Args>(args)...)));
}
template<typename E, typename... Args>
static inline void set_flag(E& reg, Args&&... args) {
	reg = combine_flags(reg,std::forward<Args>(args)...);
}
template<typename E, typename... Args>
static inline void clear_flag(E& reg, Args&&... args) {
	reg = static_cast<E>(cast_underlying(reg) & ~cast_underlying(combine_flags(std::forward<Args>(args)...)));
}
template<typename E, typename... Args>
constexpr static inline bool has_flag(E reg, Args&&... args) {
	return  (cast_underlying(reg) & cast_underlying(combine_flags<E>(std::forward<Args>(args)...)))
			== cast_underlying(combine_flags<E>(std::forward<Args>(args)...));
}
enum class irq_prio {
	Critical = 0,
	Clock = 1,
	Tty = 2,
	Bio = 3,
	Normal = 15,
};
class user {
public:
	void sleep(void* ptr,int priority);
	void wakeup(void* ptr);
	irq_prio spl(irq_prio prio);
};
struct buf {
	enum buf_flags {
		B_FREE = 0,
		B_BUSY  = 	(1<<0),  // buffer is locked by some process
		B_VALID =	(1<<1),  // buffer has been read from disk
		B_DIRTY =	(1<<2),  // buffer needs to be written to disk
		B_DELAY =	(1<<3),  // delay write till release
	};
	virtual void read() = 0;
	virtual void write() =0;
	virtual size_t size() const =0;

	virtual void valid(bool value) const = 0;
	virtual void dirty(bool value) const = 0;
	virtual void* data() =0;
	virtual ~buf() {}
	inline buf_flags flags() const { return _flags; }
private:
	inline void flags(buf_flags f) { _flags = f; }
	friend struct bdevsw;
	buf_flags _flags;
};

struct bdevsw {
	constexpr static size_t MAXBDEVSW = 10;
	virtual void open(dev_t dev, int mode);
	virtual void close(dev_t dev);
	virtual void strategy(buf& b);
	virtual ~bdevsw() {}
	static bdevsw* drivers[MAXBDEVSW];
};

class irq_lock {
	user& u;
	irq_prio pri;
public:
	irq_lock(user &u, irq_prio pri = irq_prio::Clock) :
		u(u), pri(u.spl(pri)) {}
	~irq_lock() { u.spl(pri); }
	irq_lock& operator=(irq_prio p) { u.spl(p); return *this; }
	bool operator==(const irq_lock& lck) { return pri == lck.pri; }
};


class os {
public:
	os();
	virtual ~os();
};

} /* namespace xv6 */

#endif /* XV6CPP_OS_H_ */
