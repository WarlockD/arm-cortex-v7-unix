/*
 * ObjectCache.h
 *
 *  Created on: Apr 18, 2017
 *      Author: warlo
 */

#ifndef XV6CPP_OBJECTCACHE_H_
#define XV6CPP_OBJECTCACHE_H_

#include <cstdint>
#include <sys\queue.h>
#include <algorithm>
//#include <macros.h>
#include <cassert>
namespace xv6 {

template<class T> class list_head {
public:
	class list_entry : public T {
	public:
		using type = T;
		using head_type = list_head<T>;
		using entry_type =  list_entry;
		using entry_pointer = entry_type*;
		list_entry() : _next(nullptr), _prev(&_next) , obj() {}
		entry_pointer next() { return _next; }
		entry_pointer prev() { return *_prev; }
		const entry_pointer next() const { return _next; }
		const entry_pointer prev() const { return _prev == &_next  ? nullptr : *_prev; }
		const bool valid() const { return _prev != &_next; }
		void remove() {
			if(_next == nullptr && _prev == &_next) return;
			if(_next != nullptr) _next->_prev = _prev;
			*_prev = _next;
			_clear();
		}
		void insert_after(entry_pointer elm){
			assert(elm && valid() && !elm->valid());
			if((elm->_next = _next) != nullptr)
				_next->_prev = & elm->_next;
			_next = elm;
			elm->_next = &_next;
		}
		void insert_before(entry_pointer elm){
			assert(elm && valid() && !elm->valid());
			elm->_prev = _prev;
			elm->_next = this;
			*_prev = elm;
			_prev = &elm->_next;
		}
	private:
		friend head_type;
		friend class entry_it;
		void _clear() { _next == NULL;_prev == &_next; }
		entry_type *_next;	/* next element */
		entry_type **_prev;	/* address of previous next element */
	};
	template<bool reverse, bool is_const> class entry_iterator {
	public:
		using head_type = list_head<T>;
		using entry_type =  list_entry;
		using type = T;
#if 0
		// redundent
		using type = typename std::conditional<is_const,
				const T,
				T>::type;
#endif
		using entry_pointer = typename std::conditional<is_const,
				const entry_type*,
				entry_type*>::type;

		entry_iterator(entry_pointer start=nullptr) : _current(start) {}
		operator type&() { return _current; }
		operator const type&() const { return _current; }
	    // overloaded prefix ++ operator
		entry_iterator operator++ () {
			if(_current != nullptr)
				_current = reverse ? _current->prev() : _current->next();
			return entry_iterator(_current);
		}
		entry_iterator operator++ (int) {
			entry_iterator t(_current);
			if(_current != nullptr)
				_current = reverse ? _current->prev() : _current->next();
			return t;
		}
		entry_iterator operator-- () {
			if(_current != nullptr)
				_current = reverse ? _current->next() : _current->prev();
			return entry_iterator(_current);
		}
		entry_iterator operator-- (int) {
			entry_iterator t(_current);
			if(_current != nullptr)
				_current = reverse ? _current->next() : _current->prev();
			return t;
		}
		bool operator==(const entry_iterator& r) const { return _current == r._current; }
		bool operator!=(const entry_iterator& r) const { return _current != r._current; }
	private:
		entry_pointer _current;
	};
	using type = T;
	using refrence = T&;
	using const_refrence = const T&;
	using pointer = T*;
	using const_pointer = const T*;
	using head_type = list_head<T>;
	using entry_type =  list_entry;
	using entry_pointer = entry_type*;
	using entry_refrence =  list_entry&;
	using iterator = entry_iterator<false,false>;
	using const_iterator = entry_iterator<false,true>;
	using reverse_iterator = entry_iterator<true,false>;
	using const_reverse_iterator = entry_iterator<true,true>;
	list_head() : _first(nullptr) {}
	void insert_head(entry_pointer elm) {
		assert(elm && !elm->valid());
		if((elm->_next = _first) != nullptr)
			_first->_prev = elm->_next;
		_first = elm;
		elm->_prev = &_first;
	}
	void insert_head(entry_refrence elm) {
		insert_head(&elm);
	}
	entry_pointer first() const { return _first; }
	entry_pointer remove_first() {
		entry_pointer t = _first;
		if(t!= nullptr) t->remove();
		return t;
	}
	bool empty() const { return _first == nullptr; }
	iterator begin() { return iterator(_first); }
	iterator end() { return iterator(nullptr); }
	const_iterator begin() const { return const_iterator(_first); }
	const_iterator end() const { return const_iterator(nullptr); }
	reverse_iterator rbegin() { return reverse_iterator(_first); }
	reverse_iterator rend() { return reverse_iterator(nullptr); }
	const_reverse_iterator rbegin() const { return const_reverse_iterator(_first); }
	const_reverse_iterator rend() const { return const_reverse_iterator(nullptr); }
protected:
	entry_pointer _first;
	friend entry_type;
};
enum class irq_prio {
	Critical = 0,
	Clock = 1,
	Tty = 2,
	Bio = 3,
	Normal = 15,
};
class user {
public:
	void sleep(void* ptr,int priority);
	void wakeup(void* ptr);
	irq_prio spl(irq_prio prio);
};

class irq_lock {
	user& u;
	irq_prio pri;
public:
	irq_lock(user &u, irq_prio pri = irq_prio::Clock) :
		u(u), pri(u.spl(pri)) {}
	~irq_lock() { u.spl(pri); }
	irq_lock& operator=(irq_prio p) { u.spl(p); return *this; }
	bool operator==(const irq_lock& lck) { return pri == lck.pri; }
};

// HASH_FUNC is size_t hash(const K& key)
template<typename T, typename K, typename HASH_FUNC,size_t STATIC_CACHE_SIZE>
class static_cache {
public:
	constexpr static size_t BUCKETS = STATIC_CACHE_SIZE >> 2;
	//static_assert(BUCKETS%2 == 0, "Needs to be divisiable by 2");
	using type = T;

	//using hash_entry = hash_head::list_entry;
	enum obj_state {
		C_FREE = 0,
		C_ALLOC = 1<<0,
		C_LOCKED = 1<<1,
		C_WANTED = 1<<2,
	};
	struct hash_info: public type {
		K key;
		int ref;
		obj_state state;
		hash_info() : key(), ref(0), state(C_FREE), T() {}
		hash_info(K k) : key(k), ref(1), state(C_ALLOC) , T() {}
		void inc_ref() {
			if(ref == 0) {
				*this = hash_entry(key);
			} else ++ref;
		}
		bool dec_ref() {
			if(--ref == 0){
				~T();
				state = C_FREE;
				ref = 0;
				return false;
			}
			return true;
		}
	};
	using hash_head = list_head<hash_info>;
	using hash_entry = hash_head::list_entry;
	static_cache() : u(nullptr) ,_prio(0),want_freelist(false) {
		for(hash_entry& e : cache) freelist.insert_head(e);
	}
	void setup_cache(user& u, int prio){
		u = &u;
		_prio = prio;
	}
	T* aquire(K k, bool want_lock = false){
		irq_lock lck(u,_prio);
		do {
			HASH_FUNC hash_func;
			hash_head& bucket = buckets[hash_func(k) % BUCKETS];
			for(hash_entry& e : bucket) {
				if(e.key == k) {
					e.inc_ref();
					return want_lock && !lock(&e.obj) ? nullptr : static_cast<T*>(&e);
				}
			}
			if(freelist.empty()) {
				hash_entry *e = freelist.remove_first();
				bucket.insert_head(e);
				e->obj = hash_entry(k); // call the constructor on the object
				if(want_lock) lock(e);
				return static_cast<T*>(e);
			}
			if(u){
				want_freelist = true;
				u->sleep(&freelist,_prio);
				want_freelist = false;
			}
		} while(1);
	}
	void release(T*o) {
		irq_lock lck(u,_prio);
		hash_entry *e = static_cast<hash_entry*>(o);
		if(e->dec_ref()) return;
		e->remove();
		freelist.insert_head(e);
		if(u && want_freelist) u->wakeup(&freelist);
	}
	bool lock(T* o) {
		hash_entry& e = to_entry(o);
		if(e.state & C_LOCKED){
			if(!u) return false;
			while(e.state & C_LOCKED) {
				e.state |= C_WANTED;
				u->sleep(o,_prio);
			}
			e.state &= ~C_WANTED;
		}
		e.state |= C_LOCKED;
		return true;
	}
	void unlock(T* o) {
		hash_entry& e = to_entry(o);
		if(e.state & C_LOCKED) {
			e.state &= ~C_LOCKED;
			if(u && e.state & C_WANTED) u->wakeup(o);
		}
	}
protected:
	user* u;
	int _prio;
	hash_head buckets[BUCKETS];
	hash_head freelist;
	bool want_freelist;
	hash_entry cache[STATIC_CACHE_SIZE];
};

} /* namespace xv6 */

#endif /* XV6CPP_OBJECTCACHE_H_ */
