#ifndef PROC_INCLUDE_
#define PROC_INCLUDE_

#include "types.h"
#include "queue.h"


// need to handle lazy

struct context {
//  --- stmdb r0!, {r1, r4-r11, lr } r1= sp at start of call
	uint32_t    sp;		   // stack before this call
    uint32_t    r4;
    uint32_t    r5;
    uint32_t    r6;
    uint32_t    r7;
    uint32_t    r8;
    uint32_t    r9;
    uint32_t    r10;
    uint32_t    r11;
    uint32_t    lr_ret;	    // lr for the return here
 // -- end software saved
    uint32_t    r0;
    uint32_t    r1;
    uint32_t    r2;
    uint32_t    r3;
    uint32_t    r12;
    uint32_t    lr_r14;
    uint32_t    pc_r15;
    uint32_t    xPsr;
};

struct fp_context {
	uint32_t regs[32];// lazy
};



// Per-CPU state, now we only support one CPU
struct cpu {
	struct context*		kstart;
	caddr_t           	heap_start;
    caddr_t           	heap_end;
    caddr_t           	kheap_start;
    caddr_t           	kheap_end;
    volatile uint   	started;        // Has the CPU started?
    int             	ncli;           // Depth of pushcli nesting.
    int             	intena;         // Were interrupts enabled before pushcli?
    // Cpu-local storage variables; see below
    struct proc*    proc;           // The currently-running process.
    struct inode	inodes[NOFILE];	// number of open files allowed
};

extern struct cpu cpus[NCPU];
extern int ncpu;

extern struct cpu* cpu;
extern struct proc* proc;

//PAGEBREAK: 17
// Saved registers for kernel context switches. The context switcher
// needs to save the callee save register, as usually. For ARM, it is
// also necessary to save the banked sp (r13) and lr (r14) registers.
// There is, however, no need to save the user space pc (r15) because
// pc has been saved on the stack somewhere. We only include it here
// for debugging purpose. It will not be restored for the next process.
// According to ARM calling convension, r0-r3 is caller saved. We do
// not need to save sp_svc, as it will be saved in the pcb, neither
// pc_svc, as it will be always be the same value.
//
// Keep it in sync with swtch.S
//



enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
enum proc_schd_type { SCHED_OTHER,SCHED_FIFO,SCHED_RR, };


// Per-process state
struct proc {
	struct context* context;		// first in proc
	struct fp_context* fp_context;  // second, in proc
	TAILQ_ENTRY(proc)	queue;		// Next in queue
	enum proc_schd_type	schd;
	uint32_t 		signal;
	uint32_t 		signal_mask;	/* bitmap of masked signals */
	uint32_t		timeout;
	uint32_t		counter;
	struct proc*	parent;			// created from this process
    size_t          sz;             // Size of process memory (bytes)
    uint32_t*       kstack;    		// stack memory, usally one page
    struct context* tf;			// trap frame, do we need?
    // we don't use trap frame as context is better
    uint32_t*       stack_end;    	// Where the end of this stack is
    uint32_t*       stack_current;  // Bottom of kernel stack for this process
    enum procstate  state;          // Process state
    pid_t		    pid;            // Process ID
    void			(*process)(int,const char**); // process
    //struct context* context;        // swtch() here to run process
    void*           chan;           // If non-zero, sleeping on chan
    int             killed;         // If non-zero, have been killed
    //struct file*    ofile[NOFILE];  // Open files
    struct inode*   cwd;            // Current directory
    char            name[16];       // Process name (debugging)
};

// Process memory is laid out contiguously, low addresses first:
//   text
//   original data and bss
//   fixed-size stack
//   expandable heap
#endif
