/*
 * os.h
 *
 *  Created on: Apr 18, 2017
 *      Author: warlo
 */

#ifndef XV6CPP_OS_H_
#define XV6CPP_OS_H_

#include <cstdint>
#include <sys\queue.h>
#include <sys\types.h>
#include <algorithm>
//#include <macros.h>
#include <cassert>
#include "list.h"
#include "bitmap.h"

namespace xv6 {

#define ALIGNED(size, align) (size / align) + ((size & (align - 1)) != 0)
#define __ALLIGNED(X) __attribute__((aligned(X)))
#define __ALLIGNED32 __ALLIGNED(sizeof(uint32_t))
#define BIT(x) (1<<(x))
#define __NAKED __attribute__((naked))
// helper functions for enums

template<typename E>
class enum_helper {
	E _flag;
public:
	using type = enum_helper<E>;
	using U = typename std::underlying_type<E>::type;
	constexpr  enum_helper() : _flag(E{}) {}
	//constexpr flag(E flag) : _flag(flag) {}
	constexpr operator E() const { return _flag; }
	template<typename... Args>
	constexpr enum_helper(Args&&... args) : _flag(cast_to(combine_flags(std::forward<Args>(args)... ))){}
	template<typename... Args>
	void set(Args&&... args) { _flag = cast_to(cast_from(_flag) | combine_flags(std::forward<Args>(args)... ));  }
	template<typename... Args>
	void clear(Args&&... args) { _flag = cast_to(cast_from(_flag) & ~combine_flags(std::forward<Args>(args)... )); }
	template<typename... Args>
	constexpr bool contains(Args&&... args) const {
		return mask_flags(_flag,combine_flags(std::forward<Args>(args)...)) ==
				combine_flags(std::forward<Args>(args)...);
	}
	enum_helper& operator|=(const enum_helper& r) { _flag = cast_to(combine_flags(_flag,r._flag)); return *this; }
	enum_helper& operator&=(const enum_helper& r) { _flag = cast_to(mask_flags(_flag,r._flag)); return *this; }
	enum_helper& operator|=(const E r) { _flag = cast_to(combine_flags(_flag,r)); return *this; }
	enum_helper& operator&=(const E r) { _flag = cast_to(mask_flags(_flag,r)); return *this; }


	constexpr enum_helper operator~() const { return enum_helper(cast_to(~combine_flags(_flag))); }

private: // helpers
	constexpr static inline E cast_to() { return static_cast<E>(U{}); }
	constexpr static inline E cast_to(U&& val) { return static_cast<E>(val); }
	constexpr static inline U cast_from() { return static_cast<U>(E{}); }
	constexpr static inline U cast_from(E&& val) { return static_cast<U>(val); }
	constexpr static inline U cast_from(type&& val) { return static_cast<U>(val._flag); }
	//constexpr static inline U combine_flags() { return cast_to(); }
	constexpr static inline U combine_flags() { return cast_from(); }
	constexpr static inline U mask_flags() { return cast_from(); }
	template<typename Q, typename... Args>
	constexpr static inline U combine_flags(Q &&left,Args&&... args) {
		return cast_from(left) | combine_flags(std::forward<Args>(args)...);
	}
	template<typename Q, typename... Args>
	constexpr static inline U mask_flags(Q &&left,Args&&... args) {
		return cast_from(left) & mask_flags(std::forward<Args>(args)...);
	}
	template<typename Q, typename FT> friend constexpr bool operator==(const enum_helper<Q>& l, FT&&r);
	template<typename Q, typename FT> friend constexpr bool operator==(FT&&r, const enum_helper<Q>& l);

	template<typename Q, typename FT> friend constexpr bool operator!=(const enum_helper<Q>& l,FT&&r);
	template<typename Q, typename FT> friend constexpr bool operator!=( FT&&r,const enum_helper<Q>& l);

	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator|(const enum_helper<Q>& l, FT&&r);
	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator|( FT&&r,const enum_helper<Q>& l);

	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator&(const enum_helper<Q>& l, FT&&r);
	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator&(FT&&r,const enum_helper<Q>& l);

};
template<typename Q, typename FT> constexpr bool operator==(const enum_helper<Q>& l, FT&&r){ return l.contains(r); }
template<typename Q, typename FT> constexpr bool operator==(FT&&r, const enum_helper<Q>& l){ return l.contains(r); }

template<typename Q, typename FT> constexpr bool operator!=(const enum_helper<Q>& l, FT&&r){ return !l.contains(r); }
template<typename Q, typename FT> constexpr bool operator!=(FT&&r, const enum_helper<Q>& l){ return !l.contains(r); }

template<typename Q, typename FT> constexpr enum_helper<Q> operator|(const enum_helper<Q>& l, FT&&r)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::combine_flags(l,r))); }
template<typename Q, typename FT> constexpr enum_helper<Q> operator|( FT&&r,const enum_helper<Q>& l)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::combine_flags(l,r))); }

template<typename Q, typename FT> constexpr enum_helper<Q> operator&(const enum_helper<Q>& l, FT&&r)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::mask_flags(l,r))); }
template<typename Q, typename FT> constexpr enum_helper<Q> operator&( FT&&r,const enum_helper<Q>& l)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::mask_flags(l,r))); }


class buf; // forward
enum class irq_prio {
	Critical = 0,
	Clock = 1,
	Tty = 2,
	Bio = 3,
	Normal = 15,
};
class user {
public:
	void sleep(void* ptr,int priority);
	void wakeup(void* ptr);
	irq_prio spl(irq_prio prio);
};



class irq_lock {
	user& u;
	irq_prio pri;
public:
	irq_lock(user &u, irq_prio pri = irq_prio::Clock) :
		u(u), pri(u.spl(pri)) {}
	~irq_lock() { u.spl(pri); }
	irq_lock& operator=(irq_prio p) { u.spl(p); return *this; }
	bool operator==(const irq_lock& lck) { return pri == lck.pri; }
};
// this class lets you pre allocate a count number of items
// but be sure you use THIS class for new and delete then

class os {
public:
	os();
	virtual ~os();
};
extern void wakeup(void *);
extern void sleep(void*, irq_prio pri);
// eveything in the unix os seem to be able to be locked, wanted, and/or has a ref count
// so why not make a class that handles this all instead of
// writing code for eveything in there


template<typename T, typename HASHF, typename EQUALF, size_t _COUNT>
class gcobject {
	using type = T;
	using stype = static_allocator<T,_COUNT>;
	static constexpr size_t COUNT = _COUNT;
	using pointer_type = type*;
	using const_pointer_type = const pointer_type;
	using id_t = size_t;

	///using static_allocator_type = static_allocator<T>;
	bool locked() const { return _lock.locked(); }
	void lock() { _lock.lock(); }
	void unlock() { _lock.unlock(); }
	template<typename...Args>
	static T* aquire(Args...args) {
		HASHF hashf;
		EQUALF equalf;
		auto bucket = storage.getbucket(hashf(std::forward<Args>(args)...));
		T* r;
		LIST_FOREACH(r, bucket,_hash) {
			if(equalf(*r,std::forward<Args>(args)...)) {
				if(++r->_ref == 1){
					storage.atable.alloc(std::forward<Args>(args)...);
				}
				return r;
			}
		}

	}
	gcobject() = delete;
	template<typename...Args>
	gcobject(Args...args) {
		HASHF hashf;
		EQUALF equalf;
		auto bucket = storage.getbucket(hashf(std::forward<Args>(args)...));
		LIST_FOREACH(_ref, bucket,_hash) {
			if(equalf(*r,std::forward<Args>(args)...)) {
				if(++_ref->_ref == 1){
					storage.atable.alloc(std::forward<Args>(args)...);
				}
				return r;
			}
		}

	}
protected:

	struct ref_t {
		T obj;
		int ref;
		simple_lock lock;
		tailq_entry<ref_t> hash; // sorted free list?
		template<typename...Args>
		ref_t(Args...args) : obj(std::forward<Args>(args)...), _ref(0) {}
	};
	ref_t* _ref;
	struct storage_t {
		using bucket_t = list_head<static_allocator> ;
		constexpr static size_t BUCKETS_SHIFT = 2;
		constexpr static size_t BUCKET_SIZE = COUNT >> BUCKETS_SHIFT;
		//tailq_head<static_allocator> freelist; // list of allocated but free
		bucket_t buckets[BUCKET_SIZE];
		bitmap_table_t<stype,COUNT> atable;  // static table of objects
		bucket_t* getbucket(size_t hash) { return &buckets[hash % BUCKET_SIZE]; }
	};
	static storage_t storage;
	friend class object_list;
};

class object_list {
	// HASH_FUNC is size_t hash(args...) and equal is bool(const T*, args...)
	template<typename T, typename EQUALF, typename HASHF,  size_t STATIC_CACHE_SIZE=64>
	class static_cache {
	public:
		constexpr static size_t BUCKETS_SHIFT = 2;
		constexpr static size_t CACHE_SIZE = STATIC_CACHE_SIZE;
		constexpr static size_t BUCKETS = STATIC_CACHE_SIZE >> BUCKETS_SHIFT;
};
	// sleep wakeup fuctions, fake ones are in the os.cpp

} /* namespace xv6 */

#endif /* XV6CPP_OS_H_ */
