#include "param.h"
#include "conf.h"
#include "buf.h"
#include "user.h"
#include "inode.h"
#include "file.h"
#define DEVMAX 10
#include "Utilities\Fatfs\src\ff.h"
#include "Utilities\Fatfs\src\ff_gen_drv.h"
#include "Utilities\Fatfs\src\drivers\sd_diskio.h"
#include <assert.h>
struct user u;
struct inode* rootdir=NULL;

struct bdevsw bdevsw[DEVMAX];
int	nblkdev=0;
struct cdevsw cdevsw[DEVMAX];
int	nchrdev=0;
int swapdev = -1;
int rootdev = -1;
struct fat_root {
	FIL fp;
	const char* path;
	size_t size;
};
struct fat_root v6_root;
FATFS fs;

/*------------------------------------------------------------/
/ Open or create a file in append mode
/------------------------------------------------------------*/
void printk(const char* fmt, ...);
time_t ktimeget() { return 0;
}
void ktimeset(time_t sec) { (void)sec; }
int fat_fs_strat(struct buf* bp ) {
	FRESULT fr;
	off_t o = bp->b_blkno << BSHIFT;
	if (o > v6_root.size) {
		bp->b_flags |= B_ERROR;
		iodone(bp);
		printk("fat_fs_strat: oversized blkno=%d off=d% size=%d\n",bp->b_blkno, o,v6_root.size);
		return -1;
	}
	bp->av_forw = NULL;
	splbio();
	UINT osize;
	if(bp->b_flags & B_READ) {
		fr=f_read(&v6_root.fp, bp->b_addr, BSIZE,&osize);
	} else {
		fr=f_write(&v6_root.fp, bp->b_addr, BSIZE,&osize);
	}
	if(fr != FR_OK || osize != BSIZE) {
		bp->b_flags |= B_ERROR;
		printk("fat_fs_strat: oversized\n");
		return -1;
	}
	iodone(bp);
#if 0
		if (rftab.d_actf==0)
			rftab.d_actf = bp;
		else
			rftab.d_actl->av_forw = bp;
		rftab.d_actl = bp;
		if (rftab.d_active==0)
			rfstart();
#endif
	spl0();
	return 0;
}
extern UART_HandleTypeDef huart1;
void USART1_IRQHandler() //__uart_irq_handler(void)
{
#if 0
	  uint32_t isrflags   = READ_REG(khuart.Instance->ISR);
	  uint32_t cr1its     = READ_REG(khuart.Instance->CR1);
//	  uint32_t cr3its     = READ_REG(khuart.Instance->CR3);
	  uint32_t errorflags;
	  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
	  if(errorflags == RESET && ((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET)){// no error
		    	volatile uint8_t chr = USART1->RDR;
		    	// get the char and bypass the handler
		    	queue_push(&(dbg_uart.rx), chr);
	  } else {
#endif
			HAL_UART_IRQHandler(&huart1);
}


int open_filler(dev_t dev, int mode) {(void)dev; (void)mode; return -1; }
struct buf fstab;

char sd_path[20];
int v6_setup() {
	FRESULT fr;
	bdevsw[0].d_strategy=  fat_fs_strat;
	bdevsw[0].d_open=  open_filler;
	bdevsw[0].d_close=  open_filler;
	bdevsw[0].d_tab = &fstab;
	nblkdev++;
	nchrdev=0;
	swapdev = 0;
	rootdev = 0;
	 binit();
	 iinit();
	// ok driver is set up
	fr=FATFS_LinkDriver(&SD_Driver, sd_path);
	assert(fr == FR_OK);
	/* Open or create a log file and ready to append */
	fr = f_mount(&fs, sd_path, 1);
	assert(fr == FR_OK);
	v6_root.path = "root.fs";
    fr = f_open(&v6_root.fp, v6_root.path, FA_WRITE | FA_READ);
    if (fr == FR_OK) {
    	v6_root.size = f_size(&v6_root.fp);
    	printk("root '%s' opened! size=%i\n", v6_root.path, v6_root.size);
    } else {
    	v6_root.size = 0;
    	printk("root not opened! '%s' size=%i\n" ,v6_root.path, v6_root.size);
    }
	// ok... this is intresting
    /* Open or create a log file and ready to append */
    // we are HERE! so now we have to manualy mount a root directory

	  // ok lets try to mount the root dir manualy
    rootdir = iget(0, (ino_t)ROOTINO);
    rootdir->i_count++;
    u.u_cdir = rootdir;

    return 0;
}
