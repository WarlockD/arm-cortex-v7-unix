//#define __ASSEMBLER__
#include "arm.h"


// should be run in protection mode
// but we are still using the sp stack?
// need to trace down when switch is called from, what isr
# Context switch
#
#   void swtch(struct context **old, struct context *new);
#
# Save current register context in old
# and then load register context from new.
# The stack is as r4_svc-r12_svc, lr_svc, sp_usr, lr_usr, and pc_usr
// this just swaps the user stack
GLOBAL(swtch)
	stmfd 	sp!, {r4-r11, lr}		// store unsaved regesters
	str 	sp,  [r0]
	mov 	sp,  r1
	stmfd 	r0,  {r4-r11, lr}		// store unsaved regesters
	bx		lr
END(swtch)


.macro	v7m_exception_entry
	cpsid	i					// to support nested expcetions, its disabled till the stack is fixed
	mrs     r3, basepri			// copy base pri
	cmp	lr, #0xfffffffd			@ check the return stack
	//cmpne	lr, #0xffffffed // floating point
	beq	1f						@ exception on process stack
	add	r12, sp, #32			@ MSP before exception
//	stmdb	sp!, {r4-r12, lr}	@ push unsaved registers
	stmdb	sp!, {r3-r12, lr}	@ push unsaved registers
	b	2f
1:
	mrs	r12, psp				@ get the process stack
	sub	sp, #CTX_FRAME_SIZE
	stmia	sp, {r3-r12, lr}	@ push unsaved registers
//	stmia	sp, {r4-r12, lr}	@ push unsaved registers
	ldmia	r12, {r0-r3, r6, r8-r10} @ load automatically saved registers
	add	r12, sp, #CTX_HW_OFFSET
	stmia	r12, {r0-r3, r6, r8-r10} @ fill in the rest of struct pt_regs
2:
	cpsie	i					// msp is where we want it to be so we can continue
.endm

.macro	v7m_exception_fast_exit
//v7m_exception_fast_exit:
	cpsid	i
	//ldmia	sp!, {r4-r12, lr}	@ restore previously saved state
	ldmia	sp!, {r3-r12, lr}	@ restore previously saved state
	msr	 basepri, r3			@ restore the base pri
	cmp	lr, #0xfffffffd		@ check the return stack
	it eq
	// cmpne	lr, #0xffffffed // fpuuu
	addeq	sp, #CTX_FRAME_SIZE >> 1	@ returning to PSP, just restore MSP
	cpsie	i					// reinable with the base pri set up
	bx	lr
.endm

// int do_trap(int irq, struct trap_frame*)
GLOBAL(all_trap_handle)
	v7m_exception_entry
	mrs	r0, ipsr
	and	r0, #0xff
	sub	r0, #16			@ IRQ number
	mov	r1, sp
	bl  do_trap
	ldr	lr, [sp, #REGS_NAME(ex_lr)]
	v7m_exception_fast_exit
END(all_trap_handle)


#if 0

GLOBAL(SVC_Handler)
	v7m_exception_entry
   	ldr		r4, [sp, #REGS_NAME(pc)]			@ get SWI instruction
   	ldrb 	r5, [r4, -2]

clrex
	v7m_exception_fast_exit
END(SVC_Handler)


GLOBAL(PendSV_Handler)

END(PendSV_Handler)

GLOBAL(SysTick_Handler)
	v7m_exception_entry
	mov	r0, sp
	bl do_systick			// void do_systick(struct trap_frame*)
	v7m_exception_fast_exit
END(SysTick_Handler)


#endif

// handle faults here
#if 0
GLOBAL(HardFault_Handler)
END(HardFault_Handler)

GLOBAL(MemManage_Handler)
END(MemManage_Handler)

GLOBAL(BusFault_Handler)
END(BusFault_Handler)

GLOBAL(UsageFault_Handler)
END(UsageFault_Handler)
#endif
