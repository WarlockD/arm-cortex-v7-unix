/*
 * context.hpp
 *
 *  Created on: Apr 27, 2017
 *      Author: Paul
 */

#ifndef OS_CONTEXT_HPP_
#define OS_CONTEXT_HPP_

#include <cstdint>
#include <cstddef>
#include <functional>
#include <type_traits>

// types
namespace os {
	using ptr_t = uint32_t;
	using memptr_t = uintptr_t;
	using l4_thread_t = uint32_t;
	using size_t = ::size_t;

	template<typename ALIGNT, typename SIZET>
	static constexpr inline ALIGNT ALIGNED(SIZET size,ALIGNT align) {
		return (size / align) + ((size & (align - 1)) != 0);
	}

	namespace l4 {

		// ipc
		static constexpr size_t  IPC_TI_MAP_GRANT =0x8;
		static constexpr size_t  IPC_TI_GRANT =02;
		static constexpr size_t  IPC_MR_COUNT =16;
		static constexpr size_t L4_NILTHREAD	=	0;
		static constexpr size_t L4_ANYTHREAD	=	0xFFFFFFFF;

		union ipc_msg_tag_t {
			struct {
				/* Number of words */
				uint32_t n_untyped : 6;
				uint32_t n_typed : 6;

				uint32_t flags : 4;	/* Type of operation */
				uint16_t label;
			} s;
			uint32_t raw;
		};

		union ipc_typed_item_t {
			struct {
				uint32_t	header : 4;
				uint32_t	dummy  : 28;
			} s;
			struct {
				uint32_t	header : 4;
				uint32_t	base  : 28;
			} map;
			uint32_t raw;
		} ;

		union ipc_time_t {
			uint16_t raw;
			struct {
				uint32_t	m : 10;
				uint32_t	e : 5;
				uint32_t	a : 1;
			} period;
			struct {
				uint32_t	m : 10;
				uint32_t	c : 1;
				uint32_t	e : 4;
				uint32_t	a : 1;
			} point;
		};

		/*
		 * KIP page. based on L4 X.2 Reference manual Rev. 7
		 */

		/*
		 * NOTE: kip_mem_desc_t differs from L4 X.2 standard
		 */
		 struct kip_mem_desc{
			uint32_t 	base;	/* Last 6 bits contains poolid */
			uint32_t	size;	/* Last 6 bits contains tag */
		};

		 union kip_apiversion{
			struct {
				uint8_t  version;
				uint8_t  subversion;
				uint8_t  reserved;
			} s;
			uint32_t raw;
		} ;

		 union kip_apiflags {
			struct {
				uint32_t  reserved : 28;
				uint32_t  ww : 2;
				uint32_t  ee : 2;
			} s;
			uint32_t raw;
		} ;

		 union  kip_memory_info{
			struct {
				uint16_t memory_desc_ptr;
				uint16_t n;
			} s;
			uint32_t raw;
		};

		 union kip_threadinfo {
			struct {
				uint32_t user_base;
				uint32_t system_base;
			} s;
			uint32_t raw;
		} ;

		struct kip_t {
			/* First 256 bytes of KIP are compliant with L4 reference
			 * manual version X.2 and built in into flash (lower kip)
			 */
			uint32_t kernel_id;
			kip_apiversion api_version;
			kip_apiflags api_flags;
			uint32_t kern_desc_ptr;

			uint32_t reserved1[17];

			kip_memory_info memory_info;

			uint32_t reserved2[20];

			uint32_t utcb_info;		/* Unimplemented */
			uint32_t kip_area_info;		/* Unimplemented */

			uint32_t reserved3[2];

			uint32_t boot_info;		/* Unimplemented */
			uint32_t proc_desc_ptr;		/* Unimplemented */
			uint32_t clock_info;		/* Unimplemented */
			kip_threadinfo thread_info;
			uint32_t processor_info;	/* Unimplemented */

			/* Syscalls are ignored because we use SVC/PendSV instead of
			 * mapping SC into thread's address space
			 */
			uint32_t syscalls[12];
		};
		static constexpr size_t UTCB_SIZE	=	128;

		struct utcb_t {
		/* +0w */
			l4_thread_t t_globalid;
			uint32_t	processor_no;
			uint32_t 	user_defined_handle;	/* NOT used by kernel */
			l4_thread_t	t_pager;
		/* +4w */
			uint32_t	exception_handler;
			uint32_t	flags;		/* COP/PREEMPT flags (not used) */
			uint32_t	xfer_timeouts;
			uint32_t	error_code;
		/* +8w */
			l4_thread_t	intended_receiver;
			l4_thread_t	sender;
			uint32_t	thread_word_1;
			uint32_t	thread_word_2;
		/* +12w */
			uint32_t	mr[8];		/* MRs 8-15 (0-8 are laying in
							   r4..r11 [thread's context]) */
		/* +20w */
			uint32_t	br[8];
		/* +28w */
			uint32_t	reserved[4];
		/* +32w */
		} ___attribute__((aligned(UTCB_SIZE))); ;

	};

	using pid_t = uint32_t ;
	static constexpr size_t CONFIG_INTR_THREAD_MAX = 32;

	 enum class thread_tag {
		idle,
		kernel,
		root,
		interrupt,
		irq_request,
		log,
		sys	= 16,				/* Systembase */
		user	= CONFIG_INTR_THREAD_MAX	/* Userbase */
	} ;

	 enum class thread_state {
		inactive,
		runnable,
		svc_blocked,
		recv_blocked,
		send_blocked
	} ;
	 struct context_t{
		uint32_t sp;
		uint32_t ret;
		uint32_t ctl;
		uint32_t regs[8];
	 #ifdef CONFIG_FPU
		/* lazy fpu */
		uint32_t fp_regs[16];
		uint32_t fp_flag;
	 #endif
	 } ;
	 class tcb_t {
		pid_t _pid;
		thread_state _state;
		uintptr_t _stack_base;
		size_t _stack_size;
		uint32_t _timeout_event;
		context_t _ctx;
		tcb_t* _sibling;
		tcb_t* _parent;
		tcb_t* _child;
	 public:
		static tcb_t *thread_by_globalid(l4_thread_t globalid);
		tcb_t *thread_init(l4_thread_t globalid, l4::utcb_t *utcb);
		tcb_t *thread_create(l4_thread_t globalid, utcb_t *utcb);
	 };



	public:
		tcb(pid_t pid) : parent_tree(), _pid(pid), _state(thread_state::inactive) ,_stack_base(0), _stack_size(0),_timeout_event(0) {}
	};

	template<typename T>
	struct thread_declare {
		constexpr const char* name;
		constexpr void operator()() {
			register void *kip_ptr asm ("r0");
			register void *utcb_ptr asm ("r1");
			T(kip_ptr, utcb_ptr);
			while (1);
		}
		thread_declare(const char* name) : name(name) {}

	} __attribute__ ((section(".user_text")));


#endif

