/*
 * ktimer.cpp
 *
 *  Created on: Apr 30, 2017
 *      Author: warlo
 */

#include <os/ktimer.hpp>
#include "bitmap.hpp"
#include <stm32f7xx.h>

#define dbg_printf(VAL,...) printk(__VA_ARGS__)
namespace {
static bool ktimer_enabled = false;
static uint32_t ktimer_delta = 0;
static uint32_t ktimer_time = 0;
static void init_systick(uint32_t tick_reload, uint32_t tick_next_reload)
{
	/* 250us at 168Mhz */
	SysTick->LOAD = tick_reload - 1;
	SysTick->VAL = 0;
	SysTick->CTRL = 0x00000007;

	if (tick_next_reload)
		SysTick->LOAD = tick_next_reload - 1;
}
static void systick_disable(){ SysTick->CTRL = 0x00000000; }
static uint32_t systick_now() { return SysTick->VAL;}
static  uint32_t systick_flag_count() { return (SysTick->CTRL & (1 << 16)) >> 16; }
static void ktimer_init(void) { init_systick(os::CONFIG_KTIMER_HEARTBEAT, 0); }

static void ktimer_disable(void) { if (ktimer_enabled) ktimer_enabled = true; }

static void ktimer_enable(uint32_t delta)
{
	if (!ktimer_enabled) {
		ktimer_delta = delta;
		ktimer_time = 0;
		ktimer_enabled = true;

#if defined(CONFIG_KDB) && \
    defined(CONFIG_KTIMER_TICKLESS) && defined(CONFIG_KTIMER_TICKLESS_VERIFY)
		tickless_verify_start(ktimer_now, ktimer_delta);
#endif	/* CONFIG_KDB */
	}
}
};
namespace os {
#define CONFIG_MAX_KT_EVENTS 30
	bitops::bitmap_table_t<ktimer_event_t,CONFIG_MAX_KT_EVENTS> ktimer_event_table;
//DECLARE_KTABLE(ktimer_event_t, ktimer_event_table, CONFIG_MAX_KT_EVENTS);

/* Next chain of events which will be executed */
ktimer_event_t *event_queue = NULL;



static void ktimer_event_recalc(ktimer_event_t* event, uint32_t new_delta)
{
	if (event) {
		dbg_printf(DL_KTIMER,
		           "KTE: Recalculated event %p D=%d -> %d\n",
		           event, event->delta, event->delta - new_delta);
		event->delta -= new_delta;
	}

}

int ktimer_event_schedule(uint32_t ticks, ktimer_event_t *kte)
{
	long etime = 0, delta = 0;
	ktimer_event_t *event = NULL, *next_event = NULL;

	if (!ticks)
		return -1;
	ticks -= ktimer_time;
	kte->next = NULL;

	if (event_queue == NULL) {
		/* All other events are already handled, so simply schedule
		 * and enable timer
		 */
		dbg_printf(DL_KTIMER,
		           "KTE: Scheduled dummy event %p on %d\n",
		           kte, ticks);

		kte->delta = ticks;
		event_queue = kte;

		ktimer_enable(ticks);
	} else {
		/* etime is total delta for event from now (-ktimer_value())
		 * on each iteration we add delta between events.
		 *
		 * Search for event chain until etime is larger than ticks
		 * e.g ticks = 80
		 *
		 * 0---17------------60----------------60---...
		 *                   ^                 ^
		 *                   |           (etime + next_event->delta) =
		 *                   |           = 120 - 17 = 103
		 *                               etime = 60 - 17 =  43
		 *
		 * kte is between event(60) and event(120),
		 * delta = 80 - 43 = 37
		 * insert and recalculate:
		 *
		 * 0---17------------60-------37-------23---...
		 *
		 * */
		next_event = event_queue;

		if (ticks >= event_queue->delta) {
			do {
				event = next_event;
				etime += event->delta;
				delta = ticks - etime;
				next_event = event->next;
			} while (next_event &&
			         ticks > (etime + next_event->delta));

			dbg_printf(DL_KTIMER,
			           "KTE: Scheduled event %p [%p:%p] with "
			           "D=%d and T=%d\n",
			           kte, event, next_event, delta, ticks);

			/* Insert into chain and recalculate */
			event->next = kte;
		} else {
			/* Event should be scheduled before earlier event */
			dbg_printf(DL_KTIMER,
			           "KTE: Scheduled early event %p with T=%d\n",
			           kte, ticks);

			event_queue = kte;
			delta = ticks;

			/* Reset timer */
			ktimer_enable(ticks);
		}

		/* Chaining events */
		if (delta < CONFIG_KTIMER_MINTICKS)
			delta = 0;

		kte->next = next_event;
		kte->delta = delta;

		ktimer_event_recalc(next_event, delta);
	}

	return 0;
}
ktimer_event_t *ktimer_event_create(uint32_t ticks,
	                                ktimer_event_handler_t handler,
	                                void *data)
{
	ktimer_event_t *kte = NULL;

	if (!handler)
		goto ret;

	kte = ktimer_event_table.construct();


	/* No available slots */
	if (kte == NULL)
		goto ret;

	kte->next = NULL;
	kte->handler = handler;
	kte->data = data;

	if (ktimer_event_schedule(ticks, kte) == -1) {
		ktimer_event_table.destroy(kte);
		kte = NULL;
	}

ret:
	return kte;
}


}/* namespace os */

extern "C" void SysTick_Handler(void)
{
	++os::ktimer_now;

	if (ktimer_enabled && ktimer_delta > 0) {
		++ktimer_time;
		--ktimer_delta;

		if (ktimer_delta == 0) {
			ktimer_enabled = 0;
			ktimer_time = ktimer_delta = 0;

#if defined(CONFIG_KDB) && \
    defined(CONFIG_KTIMER_TICKLESS) && defined(CONFIG_KTIMER_TICKLESS_VERIFY)
			tickless_verify_stop(ktimer_now);
#endif	/* CONFIG_KDB */

		//	softirq_schedule(KTE_SOFTIRQ);
		}
	}
}
