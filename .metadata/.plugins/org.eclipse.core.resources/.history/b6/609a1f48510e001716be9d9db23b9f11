//
// File descriptors
//

#include "types.h"
#include "defs.h"
#include "param.h"
#include "fs.h"
#include "file.h"
#include "spinlock.h"

struct devsw devsw[NDEV];
struct {
    struct file file[NFILE];
} ftable;

void fileinit (void)
{

}



// Increment ref count for file f.
struct inode* filedup (struct inode* i)
{
	if(i->ref < 1)  panic("filedup");
    i->ref++;
    return i;
}

// Close file f.  (Decrement ref count, close when reaches 0.)
void fileclose (struct inode* f)
{
    if (f->ref < 1) panic("fileclose");
    if (--f->ref > 0)return;
    if(f->type != INO_FILE) panic("fileclose: not file");

	switch(f->type) {
	case INO_PIPE:
		pipeclose(f->pipe, f->mode);
		break;
	case INO_FILE:
		assert(f_close(&f->file)==FR_OK);
		break;
	case INO_DIR:
		assert(f_closedir(&f->dir)==FR_OK);
		break;
	default:
		panic("fileclose: not file");
		break;
	}
    f->ref = 0;
    f->type = INO_EMPTY;
}

// Get metadata about file f.
int filestat (struct inode* f, struct stat *st)
{
    if (f->type == FD_INODE) {
        ilock(f->ip);
        stati(f->ip, st);
        iunlock(f->ip);

        return 0;
    }

    return -1;
}

// Read from file f.
int fileread (struct file *f, char *addr, int n)
{
    int r;

    if (f->readable == 0) {
        return -1;
    }

    if (f->type == FD_PIPE) {
        return piperead(f->pipe, addr, n);
    }

    if (f->type == FD_INODE) {
        ilock(f->ip);

        if ((r = readi(f->ip, addr, f->off, n)) > 0) {
            f->off += r;
        }

        iunlock(f->ip);

        return r;
    }

    panic("fileread");
    return -1; // never gets here
}

//PAGEBREAK!
// Write to file f.
int filewrite (struct file *f, char *addr, int n)
{
    int r;
    int i;
    int max;
    int n1;

    if (f->writable == 0) {
        return -1;
    }

    if (f->type == FD_PIPE) {
        return pipewrite(f->pipe, addr, n);
    }

    if (f->type == FD_INODE) {
        // write a few blocks at a time to avoid exceeding
        // the maximum log transaction size, including
        // i-node, indirect block, allocation blocks,
        // and 2 blocks of slop for non-aligned writes.
        // this really belongs lower down, since writei()
        // might be writing a device like the console.
        max = ((LOGSIZE - 1 - 1 - 2) / 2) * 512;
        i = 0;

        while (i < n) {
            n1 = n - i;

            if (n1 > max) {
                n1 = max;
            }

            begin_trans();
            ilock(f->ip);

            if ((r = writei(f->ip, addr + i, f->off, n1)) > 0) {
                f->off += r;
            }

            iunlock(f->ip);
            commit_trans();

            if (r < 0) {
                break;
            }

            if (r != n1) {
                panic("short filewrite");
            }

            i += r;
        }

        return i == n ? n : -1;
    }

    panic("filewrite");
    return -1;// never gets here
}

