/*
 * nuttxinode.cpp
 *
 *  Created on: Apr 24, 2017
 *      Author: warlo
 */

#include "nuttxinode.h"
#include "bitmap.h"
#include <cassert>

#define CONFIG_SEM_PREALLOCHOLDERS 20
#define getpid() (0) /* filler */
#define pid_t int16_t
namespace nuttx {
#define NO_HOLDER ((pid_t)-1);
	using alloc_table_t = bitops::bitmap_table_t<nuttx_inode, 64>;
	static alloc_table_t alloc_table;

	void* nuttx_inode::operator new(size_t size){
		assert(size < alloc_table_t::TYPE_SIZE);
		return alloc_table.alloc();
	}
	void nuttx_inode::operator delete(void *ptr){
		alloc_table.free(ptr);
	}
	struct inode_sem_s
	{
	  bitops::simple_semaphore   sem;     /* The semaphore */
	  pid_t   holder;  /* The current holder of the semaphore */
	  int16_t count;   /* Number of counts held */
	  inode_sem_s() : sem(1), holder(-1), count(0) {}
	  void take(){
		  pid_t me = getpid();
		  if(me == holder){
			  count++;
			  assert(count > 0);
		  } else {
			  sem.wait();
			  holder= me;
			  count = 1;
		  }
	  }
	  void give(){
		  assert(holder == getpid());
		  if(count >1) count--;
		  else {
			  holder = NO_HOLDER;
			  count =0;
			  sem.post();
		  }
	  }
	};
	static inode_sem_s g_inode_sem;
	static nuttx_inode  _g_rootnode("");
	static nuttx_inode *g_root_inode = &_g_rootnode;
#define dircharnull(c) ((c) == '\\' || (c) == '/' || (c) == '\0')
#define dirchar(c) ((c) == '\\' || (c) == '/')
	static int _inode_compare(const char *fname, const char *nname)
	{
	  if (!nname) return 1;
	  if (!fname)return -1;
	  for (;;)
	    {
	      if(*nname=='\0'){
	          if (dirchar(*fname))
	              return 0; /* Yes.. return match */
	          else
	              return 1;/* No... return find name > node name */
	      }
	      else if (dirchar(*fname)){ /* At end of find name? */
	          return -1; /* Yes... return find name < node name */
	        }
	      /* Check for non-matching characters */
	      else if (*fname > *nname)  return 1;
	      else if (*fname < *nname)  return -1;
	      else { fname++; nname++; }
	    }
	  return 0; // never gets here
	}
	static const char *inode_nextname(const char *name)
	{
		while (*name && !dirchar(*name)) name++;
		if (*name) name++; // skip over the '/'
		return name;
	}
	nuttx_inode *nuttx_inode::search(const char **path, nuttx_inode **peer,nuttx_inode **parent,const char **relpath){
		 const char   *name  = *path;
		 while(dirchar(*name)) name++; /* Skip over leading '/' */
		 nuttx_inode *node  = this;
		 nuttx_inode *left  = nullptr;
		 nuttx_inode *above = nullptr;

		  while (node)
		    {
		      int result = _inode_compare(name, node->_name);

		      /* Case 1:  The name is less than the name of the node.
		       * Since the names are ordered, these means that there
		       * is no peer node with this name and that there can be
		       * no match in the fileystem.
		       */

		      if (result < 0)
		        {
		          node = nullptr;
		          break;
		        }

		      /* Case 2: the name is greater than the name of the node.
		       * In this case, the name may still be in the list to the
		       * "right"
		       */

		      else if (result > 0)
		        {
		          left = node;
		          node = LIST_NEXT(node,_peer);
		        }

		      /* The names match */

		      else
		        {
		          /* Now there are three more possibilities:
		           *   (1) This is the node that we are looking for or,
		           *   (2) The node we are looking for is "below" this one.
		           *   (3) This node is a mountpoint and will absorb all request
		           *       below this one
		           */

		          name = inode_nextname(name);
		          if (*name == '\0' || node->_flags == type::mountpt)
		            {
		              /* Either (1) we are at the end of the path, so this must be the
		               * node we are looking for or else (2) this node is a mountpoint
		               * and will handle the remaining part of the pathname
		               */

		              if (relpath)
		                {
		                  *relpath = name;
		                }
		              break;
		            }
		          else
		            {
		              /* More to go, keep looking at the next level "down" */

		              above = node;
		              left  = NULL;
		              node = LIST_FIRST(&node->_child);
		            }
		        }
		    }

		  /* node is null.  This can happen in one of four cases:
		   * With node = NULL
		   *   (1) We went left past the final peer:  The new node
		   *       name is larger than any existing node name at
		   *       that level.
		   *   (2) We broke out in the middle of the list of peers
		   *       because the name was not found in the ordered
		   *       list.
		   *   (3) We went down past the final parent:  The new node
		   *       name is "deeper" than anything that we currently
		   *       have in the tree.
		   * with node != NULL
		   *   (4) When the node matching the full path is found
		   */

		  if (peer) *peer = left;
		  if (parent) *parent = above;
		  *path = name;
		  return node;
	}
	const char *inode_basename(const char *name)
	{
		const char *basename = nullptr;
		for (;;) {
			name = inode_nextname(name);
			if (name == nullptr || *name == '\0') break;
			basename = name;
		}
		return basename;
	}
	nuttx_inode *nuttx_inode::root_search(const char **path,nuttx_inode **peer,nuttx_inode **parent,const char **relpath){
		if (path == nullptr || *path == nullptr || *path[0] == '\0'  || !dircharnull(*path[0]))  return nullptr;
		return g_root_inode->search(path,peer,parent,relpath);
	}
	nuttx_inode *nuttx_inode::root_find(const char *path, const char **relpath){
		if (path == nullptr || path[0] == '\0' || !dirchar(path[0]))  return nullptr;
		return g_root_inode->find(path,relpath);
	}
	nuttx_inode *nuttx_inode::find(const char *path, const char **relpath)
	{
		nuttx_inode * node;
		if (path == nullptr || path[0] == '\0')  return nullptr;
	  /* Find the node matching the path.  If found, increment the count of
	   * references on the node.
	   */
	  node = search(&path, nullptr, nullptr, relpath);
	  if (node)  node->addref();
	  return node;
	}
	nuttx_inode::~nuttx_inode() {
		//release();
		assert(_crefs==0);
	}
	void nuttx_inode::release()
	{
		if (bitops::atomic_sub_return(1,&_crefs) <= 0){
			g_inode_sem.take();
			LIST_REMOVE(this,_peer); // we should be unlinked already but this just makes sure
			nuttx_inode*c,*n;
			LIST_FOREACH_SAFE(c, &_child, _peer,n)
				c->release(); // release all the children
			g_inode_sem.give();
			_crefs = 0;
			delete this;
		}
	}
	nuttx_inode * nuttx_inode::link(const char* name, type t=type::special){

	}
	nuttx_inode * nuttx_inode::unlink(const char* name){
		const char       *name = path;
		  FAR struct inode *node;
		  FAR struct inode *peer;
		  FAR struct inode *parent;

		  /* Verify parameters.  Ignore null paths and relative paths */

		  if (path == NULL || path[0] != '/')
		    {
		      return NULL;
		    }

		  /* Find the node to unlink */

		  node = inode_search(&name, &peer, &parent, (const char **)NULL);
		  if (node)
		    {
		      /* If peer is non-null, then remove the node from the right of
		       * of that peer node.
		       */

		      if (peer)
		        {
		          peer->i_peer = node->i_peer;
		        }

		      /* If parent is non-null, then remove the node from head of
		       * of the list of children.
		       */

		      else if (parent)
		        {
		          parent->i_child = node->i_peer;
		        }

		      /* Otherwise, we must be removing the root inode. */

		      else
		        {
		           g_root_inode = node->i_peer;
		        }

		      node->i_peer = NULL;
		    }

		  return node;
	}
	void nuttx_inode::unlink(){
		g_inode_sem.take();
		LIST_REMOVE(this,_peer);
		g_inode_sem.give();
	}

} /* namespace xv6 */
