/*
 * buf.hpp
 *
 *  Created on: Apr 27, 2017
 *      Author: Paul
 */

#ifndef OS_BUF_HPP_
#define OS_BUF_HPP_

#include "types.h"

namespace os {
// buffer interface
	class buf {
	protected:
		size_t _count;
		size_t _first;
		size_t _last;
		buf() : _count(0), _first(0), _last(0) {}
	public:
		virtual uint8_t* data() = 0;
		virtual size_t size() const = 0;
		void clear() override final { _count = 0; _last = _first; };
		size_t count() const override final { return  _count; }
		size_t free_size() const override final { return size() - count; }
		int write(const uint8_t* data, const size_t count) override final {
			for(int i=0;i < count; i++){
				if(_count >= size()) return i;
				put(data[i]);
			}
			return (int)count;
		}
		int read(const uint8_t* data, const size_t count) override final {
			for(int i=0;i < count; i++){
				if(_count == 0) return i;
				data[i] = get();
			}
			return (int)count;
		}
		int get() override final {
			if(_count==0) return -1;
		    uint8_t c = buf[_first++];
		    if(_first == size()) _first = 0;
		    --count;
		    return c;
		}
		int put(int c) override final {
			if(_count==size()) return -1;
		    buf[_last++] = c;
		    if(_last == size())  _last = 0;
		    ++count;
		    return c;
		}
		virtual ~buf() {}
	};

	template<size_t _SIZE>
	struct fixed_buf : public buf {
		constexpr static size_t SIZE = _SIZE;
		uint8_t _buffer[SIZE];
	public:
		fixed_buf() : buf() {}
		uint8_t* data() { return _buffer; }
		size_t size() { return SIZE; }
	};


	class ostream {
		// Static data is placed in this class template to allow header-only
		// configuration.
		template <typename T = void>
		struct FMT_API BasicData {
		  static const uint32_t POWERS_OF_10_32[];
		  static const uint64_t POWERS_OF_10_64[];
		  static const char DIGITS[];
		};

		#if FMT_USE_EXTERN_TEMPLATES
		extern template struct BasicData<void>;
		#endif

		typedef BasicData<> Data;

		// Returns the number of decimal digits in n. Leading zeros are not counted
		// except for n == 0 in which case count_digits returns 1.
		template <typename Int>
		inline typename std::make_unsigned<Int> to_unsigned(Int value) {
		  assert(value >= 0); //  "negative value"
		  return static_cast<typename std::make_unsigned<Int>::type>(value);
		}

		inline unsigned count_digits(uint64_t n) {
			__builtin_clzll
		  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
		  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
		  int t = (64 - __builtin_clzll(n | 1)) * 1233 >> 12;
		  return to_unsigned(t) - (n < Data::POWERS_OF_10_64[t]) + 1;
		}
		inline unsigned count_digits(uint32_t n) {
		  int t = (32 - __builtin_clz(n | 1)) * 1233 >> 12;
		  return to_unsigned(t) - (n < Data::POWERS_OF_10_32[t]) + 1;
		}
		buf& _stream;
	public:
		ostream(buf& s) : _stream(s) {}
		ostream& operator<<(int value);
		ostream& operator<<(int value);
		void putch(char ch);
			void puts(const char * s);
			void put_hex(uint8_t b);
			void put_hex(uint16_t w) __attribute__((__noinline__))
			{
				put_hex((uint8_t)(w >> 8));
				put_hex((uint8_t)w);
			}
			void put_hex(uint32_t w) __attribute__((__noinline__))
			{
				put_hex((uint16_t)(w >> 16));
				put_hex((uint16_t)w);
			}
			void put_hex(int i) { put_hex((uint32_t)i); }
			dbg_uart_t& operator<< (char value) { putch(value); return *this; }
			dbg_uart_t& operator<< (const char* value)  { puts(value); return *this; }
		//	dbg_uart_t& operator<< (int value)  { put_hex(value); return *this; }
		//	dbg_uart_t& operator<< (uint16_t value)  { put_hex(value); return *this; }
		//	dbg_uart_t& operator<< (uint32_t value)  { put_hex(value); return *this; }
			dbg_uart_t& operator<< (int value)
			{
				char buf[20];
				puts(ftoa(value, buf, 0));
				return *this;
			}
			dbg_uart_t& operator<< (uint16_t value)
			{
				char buf[20];
				puts(ftoa(value, buf, 0));
				return *this;
			}
			dbg_uart_t& operator<< (uint32_t value)
			{
				char buf[20];
				puts(ftoa(value, buf, 0));
				return *this;
			}
			dbg_uart_t& operator<< (double value)
			{
				char buf[20];
				puts(ftoa(value, buf, 1));
				return *this;
			}
			dbg_uart_t& operator<< (size_t value) { return operator<< ((uint32_t)value); }
	};



} /* namespace os */

#endif /* OS_BUF_HPP_ */
