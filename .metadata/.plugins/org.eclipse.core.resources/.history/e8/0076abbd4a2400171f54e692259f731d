/*
 * ObjectCache.h
 *
 *  Created on: Apr 18, 2017
 *      Author: warlo
 */

#ifndef XV6CPP_OBJECTCACHE_H_
#define XV6CPP_OBJECTCACHE_H_

#include "os.h"
#include <functional>

namespace xv6 {

template<class T> class list_head {
public:
	using type =  T;
	using refrence =  T&;
	using const_refrence =  const  T&;
	using pointer =  T*;
	using const_pointer =  const  T*;

	class list_entry : public T {
	public:
		using type = T;
		using head_type = list_head<T>;
		using entry_type =  list_entry;
		using entry_pointer = entry_type*;
		list_entry() : _next(nullptr), _prev(&_next) {}
		~list_entry() { remove(); }

		entry_pointer next() { return _next; }
		entry_pointer prev() { return *_prev; }
		const entry_pointer next() const { return _next; }
		const entry_pointer prev() const { return _prev == &_next  ? nullptr : *_prev; }
		const bool valid() const { return _prev != &_next; }
		void remove() {
			if(valid()){
				if(_next != nullptr) _next->_prev = _prev;
				*_prev = _next;
				_next = NULL;_prev = &_next;
			}
		}
		void insert_after(entry_pointer elm){
			assert(elm && valid() && !elm->valid());
			if((elm->_next = _next) != nullptr)
				_next->_prev = & elm->_next;
			_next = elm;
			elm->_next = &_next;
		}
		void insert_before(entry_pointer elm){
			assert(elm && valid() && !elm->valid());
			elm->_prev = _prev;
			elm->_next = this;
			*_prev = elm;
			_prev = &elm->_next;
		}
	private:
		friend head_type;
		friend class entry_it;
		entry_type *_next;	/* next element */
		entry_type **_prev;	/* address of previous next element */
	};
	template<bool reverse, bool is_const> class entry_iterator {
	public:
		using head_type = list_head<T>;
		using entry_type =  list_entry;
		using type = T;
#if 0
		// redundent
		using type = typename std::conditional<is_const,
				const T,
				T>::type;
#endif
		using entry_pointer = typename std::conditional<is_const,
				const entry_type*,
				entry_type*>::type;

		entry_iterator(entry_pointer start=nullptr) : _current(start) {}
		operator type&() { return _current; }
		operator const type&() const { return _current; }
	    // overloaded prefix ++ operator
		entry_iterator operator++ () {
			if(_current != nullptr)
				_current = reverse ? _current->prev() : _current->next();
			return entry_iterator(_current);
		}
		entry_iterator operator++ (int) {
			entry_iterator t(_current);
			if(_current != nullptr)
				_current = reverse ? _current->prev() : _current->next();
			return t;
		}
		entry_iterator operator-- () {
			if(_current != nullptr)
				_current = reverse ? _current->next() : _current->prev();
			return entry_iterator(_current);
		}
		entry_iterator operator-- (int) {
			entry_iterator t(_current);
			if(_current != nullptr)
				_current = reverse ? _current->next() : _current->prev();
			return t;
		}
		bool operator==(const entry_iterator& r) const { return _current == r._current; }
		bool operator!=(const entry_iterator& r) const { return _current != r._current; }
	private:
		entry_pointer _current;
	};

	using head_type = list_head<T>;
	using entry_type =  list_entry;
	using entry_pointer = entry_type*;
	using entry_refrence =  list_entry&;
	using iterator = entry_iterator<false,false>;
	using const_iterator = entry_iterator<false,true>;
	using reverse_iterator = entry_iterator<true,false>;
	using const_reverse_iterator = entry_iterator<true,true>;
	list_head() : _first(nullptr) {}
	void insert_head(entry_pointer elm) {
		assert(elm && !elm->valid());
		if((elm->_next = _first) != nullptr)
			_first->_prev = &elm->_next;
		_first = elm;
		elm->_prev = &_first;
	}
	void insert_head(entry_refrence elm) {
		insert_head(&elm);
	}
	entry_pointer first() const { return _first; }
	entry_pointer remove_first() {
		entry_pointer t = _first;
		if(t!= nullptr) t->remove();
		return t;
	}
	bool empty() const { return _first == nullptr; }
	iterator begin() { return iterator(_first); }
	iterator end() { return iterator(nullptr); }
	const_iterator begin() const { return const_iterator(_first); }
	const_iterator end() const { return const_iterator(nullptr); }
	reverse_iterator rbegin() { return reverse_iterator(_first); }
	reverse_iterator rend() { return reverse_iterator(nullptr); }
	const_reverse_iterator rbegin() const { return const_reverse_iterator(_first); }
	const_reverse_iterator rend() const { return const_reverse_iterator(nullptr); }
protected:
	entry_pointer _first;
	friend entry_type;
};

// HASH_FUNC is size_t hash(args...) and equal is bool(const T*, args...)
template<typename T, typename EQUALF, typename HASHF,  size_t STATIC_CACHE_SIZE=64>
class static_cache {
public:
	constexpr static size_t BUCKETS_SHIFT = 2;
	constexpr static size_t CACHE_SIZE = STATIC_CACHE_SIZE;
	constexpr static size_t BUCKETS = STATIC_CACHE_SIZE >> BUCKETS_SHIFT;
	//static_assert(BUCKETS%2 == 0, "Needs to be divisiable by 2");
	using type = T;
	//using hash_entry = hash_head::list_entry;
	enum obj_state {
		C_FREE = 0,
		C_ALLOC = 1<<0,
		C_LOCKED = 1<<1,
		C_WANTED = 1<<2,
	};
	struct hash_info: public type {
		int ref;
		obj_state state;
		size_t pos;
		hash_info(size_t pos, int ref, obj_state state) :  pos(pos), ref(ref), state(state),type() {}
		void inc_ref() {
			if(ref == 0)
				*this = hash_info(pos,0,B_ALLOC); // call constructor
			++ref;
		}
		bool dec_ref() {
			if(--ref == 0){
				~type();
				state = C_FREE;
				ref = 0;
				return false;
			}
			return true;
		}
	};
	using hash_head = list_head<hash_info>;
	using  hash_entry = typename hash_head::list_entry;

	static_cache() : u(nullptr) ,_prio(0),want_freelist(false) {
		size_t p=0;
		for(hash_entry& e : cache) {
			e.pos = p++;
			freelist.insert_head(e);
		}
	}
	void setup_cache(user& u, int prio){
		u = &u;
		_prio = prio;
	}
	template<typename... Args>
	T* aquire(Args&&... args){
		if(u) irq_lock lck(*u,_prio);
		do {
			HASHF hashf;
			EQUALF equalsf;
			size_t h = hashf(std::forward<Args>(args)...);
			hash_head& bucket = buckets[h % BUCKETS];
			for(hash_entry& e : bucket) {
				if(equalsf(e,std::forward<Args>(args)...)) {
					e.inc_ref();
					if(e.state & C_LOCKED){// need to make sure its not locked
						if(!u) return nullptr;
						while(e.state & C_LOCKED) {
							e.state |= C_WANTED;
							u->sleep(&e,_prio);
						}
						e.state &= ~C_WANTED;
					}
					return static_cast<T*>(&e);
				}
			}
			if(freelist.empty()) {
				hash_entry *e = freelist.remove_first();
				bucket.insert_head(e);
				e->inc_ref();
				return static_cast<T*>(e);
			}
			if(u){
				want_freelist = true;
				u->sleep(&freelist,_prio);
				want_freelist = false;
			}
		} while(1);
	}
	void release(T*o) {
		irq_lock lck(u,_prio);
		hash_entry *e = static_cast<hash_entry*>(o);
		if(e->dec_ref()) return;
		e->remove();
		freelist.insert_head(e);
		if(u && want_freelist) u->wakeup(&freelist);
	}
	bool lock(T* o) {
		hash_entry& e = to_entry(o);
		if(e.state & C_LOCKED){
			if(!u) return false;
			while(e.state & C_LOCKED) {
				e.state |= C_WANTED;
				u->sleep(o,_prio);
			}
			e.state &= ~C_WANTED;
		}
		e.state |= C_LOCKED;
		return true;
	}
	void unlock(T* o) {
		hash_entry& e = to_entry(o);
		if(e.state & C_LOCKED) {
			e.state &= ~C_LOCKED;
			if(u && (e.state & C_WANTED)) u->wakeup(o);
		}
	}
protected:
	user* u;
	int _prio;
	hash_head buckets[BUCKETS];
	hash_head freelist;
	bool want_freelist;
	hash_entry cache[STATIC_CACHE_SIZE];
	hash_entry * _search(K k) {
		hash_head& bucket = buckets[k % BUCKETS];
		for(hash_entry& e : bucket) {
			if(e.key == k) {
				e.inc_ref();
				return &e;
			}
		}
		return nullptr;
	}
};

} /* namespace xv6 */

#endif /* XV6CPP_OBJECTCACHE_H_ */
