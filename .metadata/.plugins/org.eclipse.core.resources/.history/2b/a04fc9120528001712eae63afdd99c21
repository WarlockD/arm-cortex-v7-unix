/*
 * os.h
 *
 *  Created on: Apr 18, 2017
 *      Author: warlo
 */

#ifndef XV6CPP_OS_H_
#define XV6CPP_OS_H_

#include <cstdint>
#include <sys\queue.h>
#include <sys\types.h>
#include <algorithm>
//#include <macros.h>
#include <cassert>
#include "list.h"

namespace xv6 {

#define ALIGNED(size, align) (size / align) + ((size & (align - 1)) != 0)
#define __ALLIGNED(X) __attribute__((aligned(X)))
#define __ALLIGNED32 __ALLIGNED(sizeof(uint32_t))
#define BIT(x) (1<<(x))
#define __NAKED __attribute__((naked))
// helper functions for enums

template<typename E>
class enum_helper {
	E _flag;
public:
	using type = enum_helper<E>;
	using U = typename std::underlying_type<E>::type;
	constexpr  enum_helper() : _flag(E{}) {}
	//constexpr flag(E flag) : _flag(flag) {}
	constexpr operator E() const { return _flag; }
	template<typename... Args>
	constexpr enum_helper(Args&&... args) : _flag(cast_to(combine_flags(std::forward<Args>(args)... ))){}
	template<typename... Args>
	void set(Args&&... args) { _flag = cast_to(cast_from(_flag) | combine_flags(std::forward<Args>(args)... ));  }
	template<typename... Args>
	void clear(Args&&... args) { _flag = cast_to(cast_from(_flag) & ~combine_flags(std::forward<Args>(args)... )); }
	template<typename... Args>
	constexpr bool contains(Args&&... args) const {
		return mask_flags(_flag,combine_flags(std::forward<Args>(args)...)) ==
				combine_flags(std::forward<Args>(args)...);
	}
	enum_helper& operator|=(const enum_helper& r) { _flag = cast_to(combine_flags(_flag,r._flag)); return *this; }
	enum_helper& operator&=(const enum_helper& r) { _flag = cast_to(mask_flags(_flag,r._flag)); return *this; }
	enum_helper& operator|=(const E r) { _flag = cast_to(combine_flags(_flag,r)); return *this; }
	enum_helper& operator&=(const E r) { _flag = cast_to(mask_flags(_flag,r)); return *this; }


	constexpr enum_helper operator~() const { return enum_helper(cast_to(~combine_flags(_flag))); }

private: // helpers
	constexpr static inline E cast_to() { return static_cast<E>(U{}); }
	constexpr static inline E cast_to(U&& val) { return static_cast<E>(val); }
	constexpr static inline U cast_from() { return static_cast<U>(E{}); }
	constexpr static inline U cast_from(E&& val) { return static_cast<U>(val); }
	constexpr static inline U cast_from(type&& val) { return static_cast<U>(val._flag); }
	//constexpr static inline U combine_flags() { return cast_to(); }
	constexpr static inline U combine_flags() { return cast_from(); }
	constexpr static inline U mask_flags() { return cast_from(); }
	template<typename Q, typename... Args>
	constexpr static inline U combine_flags(Q &&left,Args&&... args) {
		return cast_from(left) | combine_flags(std::forward<Args>(args)...);
	}
	template<typename Q, typename... Args>
	constexpr static inline U mask_flags(Q &&left,Args&&... args) {
		return cast_from(left) & mask_flags(std::forward<Args>(args)...);
	}
	template<typename Q, typename FT> friend constexpr bool operator==(const enum_helper<Q>& l, FT&&r);
	template<typename Q, typename FT> friend constexpr bool operator==(FT&&r, const enum_helper<Q>& l);

	template<typename Q, typename FT> friend constexpr bool operator!=(const enum_helper<Q>& l,FT&&r);
	template<typename Q, typename FT> friend constexpr bool operator!=( FT&&r,const enum_helper<Q>& l);

	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator|(const enum_helper<Q>& l, FT&&r);
	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator|( FT&&r,const enum_helper<Q>& l);

	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator&(const enum_helper<Q>& l, FT&&r);
	template<typename Q, typename FT> friend constexpr enum_helper<Q> operator&(FT&&r,const enum_helper<Q>& l);

};
template<typename Q, typename FT> constexpr bool operator==(const enum_helper<Q>& l, FT&&r){ return l.contains(r); }
template<typename Q, typename FT> constexpr bool operator==(FT&&r, const enum_helper<Q>& l){ return l.contains(r); }

template<typename Q, typename FT> constexpr bool operator!=(const enum_helper<Q>& l, FT&&r){ return !l.contains(r); }
template<typename Q, typename FT> constexpr bool operator!=(FT&&r, const enum_helper<Q>& l){ return !l.contains(r); }

template<typename Q, typename FT> constexpr enum_helper<Q> operator|(const enum_helper<Q>& l, FT&&r)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::combine_flags(l,r))); }
template<typename Q, typename FT> constexpr enum_helper<Q> operator|( FT&&r,const enum_helper<Q>& l)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::combine_flags(l,r))); }

template<typename Q, typename FT> constexpr enum_helper<Q> operator&(const enum_helper<Q>& l, FT&&r)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::mask_flags(l,r))); }
template<typename Q, typename FT> constexpr enum_helper<Q> operator&( FT&&r,const enum_helper<Q>& l)
	{ return enum_helper<Q>(enum_helper<Q>::cast_to(enum_helper<Q>::mask_flags(l,r))); }


class buf; // forward
enum class irq_prio {
	Critical = 0,
	Clock = 1,
	Tty = 2,
	Bio = 3,
	Normal = 15,
};
class user {
public:
	void sleep(void* ptr,int priority);
	void wakeup(void* ptr);
	irq_prio spl(irq_prio prio);
};



class irq_lock {
	user& u;
	irq_prio pri;
public:
	irq_lock(user &u, irq_prio pri = irq_prio::Clock) :
		u(u), pri(u.spl(pri)) {}
	~irq_lock() { u.spl(pri); }
	irq_lock& operator=(irq_prio p) { u.spl(p); return *this; }
	bool operator==(const irq_lock& lck) { return pri == lck.pri; }
};
// this class lets you pre allocate a count number of items
// but be sure you use THIS class for new and delete then

class os {
public:
	os();
	virtual ~os();
};
extern void wakeup(void *);
extern void sleep(void*, irq_prio pri);
// eveything in the unix os seem to be able to be locked, wanted, and/or has a ref count
// so why not make a class that handles this all instead of
// writing code for eveything in there


template<typename T>
class object {
	enum state {
		free = 0,
		inuse = 1<<0,
		locked = 1<<1,
		wanted = 1<<2,
	};
	bool valid() const { return _state == state::inuse; }
	bool locked() const { return _state == state::locked; }
	void lock() { _lock.lock(); }
	void unlock() { _lock.unlock(); }
	T& operator->() {
		assert(valid());
		while(_state == state::locked)
			_state |= state::wanted;
	}
protected:
	T* _obj;
	int _ref;
	simple_lock _lock;
	tailq_entry<object> _free; // on the free list
	list_entry<object> _hash; // or owned list
	enum_helper<state> _state;
	friend class object_list;
};

class object_list {
	// HASH_FUNC is size_t hash(args...) and equal is bool(const T*, args...)
	template<typename T, typename EQUALF, typename HASHF,  size_t STATIC_CACHE_SIZE=64>
	class static_cache {
	public:
		constexpr static size_t BUCKETS_SHIFT = 2;
		constexpr static size_t CACHE_SIZE = STATIC_CACHE_SIZE;
		constexpr static size_t BUCKETS = STATIC_CACHE_SIZE >> BUCKETS_SHIFT;
};
	// sleep wakeup fuctions, fake ones are in the os.cpp

} /* namespace xv6 */

#endif /* XV6CPP_OS_H_ */
