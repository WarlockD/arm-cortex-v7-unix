/*
 * nuttxinode.cpp
 *
 *  Created on: Apr 24, 2017
 *      Author: warlo
 */

#include "nuttxinode.h"
#include "bitmap.h"
#include <cassert>

#define CONFIG_SEM_PREALLOCHOLDERS 20
#define getpid() (0) /* filler */
namespace nuttx {
	//static nuttx_inode  nuttx_inode::g_rootnode("");
/* Preallocated holder structures */
	static bitops::bitmap_table_t<semholder_t,CONFIG_SEM_PREALLOCHOLDERS> g_holderalloc;


	semholder_t* sem_t::addholder(pid_t pid){
		semholder_t* h;
		LIST_FOREACH(h, &_hhead, _flink)
			if(h->_hpid == pid) {
				++h->_counts;
				return h;
			}
		h = g_holderalloc.create();
		h->_hpid = pid;
		h->_counts = 1;
		assert(h);
		LIST_INSERT_HEAD(&_hhead, h, _flink);
		return h;
	}
	  semholder_t* sem_t::releaseholder(pid_t pid){
		semholder_t* h;
		LIST_FOREACH(h, &_hhead, _flink)
			if(h->_hpid == pid) {
				if(--h->_counts == 0){
					LIST_REMOVE(h,_flink);
					g_holderalloc.free(h);
				}
				;
				return h;
			}
	  }
	  int sem_t::destroy(){
		  getpid()
	  }
	  int sem_t::wait(){
		  // enter critical
		  /* Check if the lock is available */
		  if(_semcount > 0) {
			   /* It is, let the task take the semaphore. */
			  --_semcount;
			  addholder(getpid());
		  }  else{
			  ++_semcount;
			  while(_semcount <0) bitops
		  }
	        {
		  if (sem->semcount > 0)
		        {


		          sem->semcount--;
		          sem_addholder(sem);
		          rtcb->waitsem = NULL;
		          ret = OK;
		        }
	  }
	  int sem_t::timedwait(const struct timespec* abstime){

	  }
	  int sem_t::trywait(){

	  }
	  bool sem_t::post(){

	  }
	  bool sem_t::getvalue(int* sval){

	  }
} /* namespace xv6 */
