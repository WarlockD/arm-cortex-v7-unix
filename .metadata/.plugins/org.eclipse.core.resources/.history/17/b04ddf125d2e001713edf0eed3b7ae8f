/*
 * memory.hpp
 *
 *  Created on: Apr 27, 2017
 *      Author: Paul
 */

#ifndef OS_MEMORY_HPP_
#define OS_MEMORY_HPP_



//#include <sys\queue.h>

#include "types.hpp"
#include "slist.hpp"


namespace os {
	namespace mpu {
		enum class Access  : uint8_t {
			None = 0x0,
			PrivReadWrite = 0x1,
			PrivReadWrite_UserReadOnly= 0x2,
			Full = 0x3,
			PrivReadOnly= 0x5,
			ReadOnly = 0x6,
		};
		enum class RegionSize : uint8_t {
			_32B = 0x04U,
			_64B = 0x05U,
			_128B = 0x06U,
			_256B = 0x07U,
			_512B = 0x08U,
			_1KB = 0x09U,
			_2KB = 0x0AU,
			_4KB = 0x0BU,
			_8KB = 0x0CU,
			_16KB = 0x0DU,
			_32KB = 0x0EU,
			_64KB = 0x0FU,
			_128KB = 0x10U,
			_256KB = 0x11U,
			_512KB = 0x12U,
			_1MB = 0x13U,
			_2MB = 0x14U,
			_4MB = 0x15U,
			_8MB = 0x16U,
			_16MB = 0x17U,
			_32MB = 0x18U,
			_64MB = 0x19U,
			_128MB = 0x1AU,
			_256MB = 0x1BU,
			_512MB = 0x1CU,
			_1GB = 0x1DU,
			_2GB = 0x1EU,
			_4GB = 0x1FU,
		};
		enum class CacheInfo {
			StronglyOrdered = 0x0,
			SharedDevice  = 0x1,
			WriteThoughNoWriteAllocate  = 02,
			WriteBackNoWriteAllocate  = 0x3,
			NonCacheable  = 0x4,
			WriteBackReadWriteAllocate  = 0x7,
			NonShareableDevice  = 0x8
		};
		class Attribites {
			static constexpr volatile uint32_t* MPU_REG_START = (volatile uint32_t*)0xE000ED90;
			uint32_t _reg;
		public:
			constexpr Attribites(uint32_t reg=0) : _reg(0) {}
			constexpr bool neverExecute() const { return (_reg & (1<<28U) )!= 0; }
			constexpr Access access() const { return static_cast<Access>((_reg >> 24) & 3); }
			constexpr bool shareable() const { return (_reg & (1<<18U) )!= 0; }
			constexpr bool cacheable() const { return (_reg & (1<<17U) )!= 0; }
			constexpr bool bufferable() const { return (_reg & (1<<16U) )!= 0; }
			constexpr bool subregonEnabled(int sub) const { return ((_reg >>8) & (1<<sub)) != 0; }
			constexpr CacheInfo cacheSettings() const { return static_cast<CacheInfo>((_reg >> 16) & 31); }
			constexpr bool enabled() const { return (_reg & 1 )!= 0; }
			constexpr RegionSize size() const { return static_cast<RegionSize>((_reg >>1)&0x1F); }
		};
	};
	//struct map coremap[CMAPSIZ];	/* space for core allocation */
	//struct map swapmap[SMAPSIZ];	/* space for swap allocation */
	struct mapent {
		size_t    	size;             /* size of this segment of the map */
		union {
			void*    	ptr;             /* start of segment */
			uintptr_t 	addr;
		};
		static uintptr_t rmalloc(mapent* map, size_t nelms, size_t size);
		static void rmfree(mapent* map, size_t nelms, void* ptr, size_t size);
	};
	template<size_t _NELMS>
	class resource_map {
		static_assert(_NELMS > 2, "Must be more than 2!");
		const char    *_name;            /* name of resource, for messages */
		std::array<mapent,_NELMS> _maps;

		//static  resource_map *kmemmap, *mbmap, *swapmap;
		//int     nswapmap;
		const static size_t ARGMAPSIZE = 16;
		//using iterator = typename std::array<mapent,_NELMS>::iterator;
		//using const_iterator = std::array<mapent,_NELMS>::const_iterator;
	public:
		constexpr static size_t NELMS = _NELMS;
		auto begin() { return _maps.begin(); }
		auto end() { return _maps.end(); }
		auto begin() const { return _maps.begin(); }
		auto end() const { return _maps.end(); }
		resource_map(void* ptr, size_t size, const char* name=nullptr)
				: _name(name), _maps{ { size, ptr }, { 0, 0} } {
		}
		resource_map(uintptr_t addr, size_t size, const char* name=nullptr)
				: _name(name), _maps{ { size, addr }, { 0, 0} } {
		}
		constexpr size_t elements() const { return  NELMS; }

		void* alloc(size_t size) {
			   /* first check arguments */
				ASSERT(size >= 0);
				    if (!size) return 0;

				    mapent *fp=nullptr;
				    uintptr_t addr;
				    /* try to find the smallest fit */
				    auto map_begin = std::begin(&map[0]);
				    auto map_end = std::end(&map[size]);
				    for (auto ep = map_begin; ep != map_end; ep++) {
				        if (!ep->addr) break; /* unused slots terminate the list */
				        if (ep->size == size) {
				            /* found exact match, use it, ... */
				            addr = ep->addr;
				            /* copy over the remaining slots ... */
				            std::copy(ep+1,map_end),ep);

				            memcpy(ep, ep+1, (char *)limit - (char *)(ep + 1));
				            /* and mark the last slot as unused */
				            limit[-1].addr = 0;
				            return addr;
				        }
				        if (ep->size > size
				            && (!fp
				            || fp->size > ep->size)) {
				            /* found a larger slot, remember the smallest of these */
				            fp = ep;
				        }
				    }
				    if (fp) {
				        /* steal requested size from a larger slot */
				        addr = fp->addr;
				        fp->addr += size;
				        fp->size -= size;
				        return addr;
				    }
				    return 0;

			return reinterpret_cast<void*>(mapent::rmalloc(_maps,NELMS,size));
		}
		void free(void* ptr, size_t size) { mapent::rmfree(_maps,NELMS,ptr, size); }
	};

}; /* namespace os */
#endif /* OS_MEMORY_HPP_ */
