/*
 * buf.h
 *
 *  Created on: Apr 18, 2017
 *      Author: warlo
 */

#ifndef XV6CPP_BUF_H_
#define XV6CPP_BUF_H_
#include "ObjectCache.h"
#include <sys\types.h>

namespace xv6 {
	struct buf {
		virtual void read() = 0;
		virtual void write() =0;
		virtual size_t size() const =0;
		virtual bool valid() const = 0;
		virtual bool dirty() const = 0;
		virtual void* data() =0;
		virtual ~buf() {}
	};

class disk_buf : public buf {
public:
	static constexpr size_t CACHE_SIZE = 64;
	static constexpr size_t BSIZE = 512;
	//static constexpr size_t BSIZE = SIZE;
	enum buf_flags {
		B_BUSY  = 	(1<<0),  // buffer is locked by some process
		B_VALID =	(1<<1),  // buffer has been read from disk
		B_DIRTY =	(1<<2),  // buffer needs to be written to disk
		B_DELAY =	(1<<3),  // delay write till release
	};
	disk_buf(dev_t dev, daddr_t sector);		// this is bread
	~disk_buf();					// make sure we are synced before we exit
	//uint8_t* operator() { return static_cast(uint8_t*)(_data); }
	dev_t dev() const { return _buf->dev; }
	daddr_t sector() const { return  _buf->sector; }
	void* data() { return  _buf->data; }
	size_t size() const { return  BSIZE; }
	bool valid() const { return _buf->flags & B_DIRTY; }
	bool dirty() const { return _buf->flags & B_VALID; }
	bool operator==(const disk_buf& r) const { return  dev() == r.dev() && sector() == r.sector(); }
private:
	struct buf_t {
		dev_t dev;
		daddr_t sector;
		buf_flags flags;
		//void* data;
		uint8_t data[BSIZE];
	};
	struct buf_hash {
		std::size_t operator()(dev_t dev, daddr_t sector) const {
			return dev<<16 ^ sector;
		}
	};
	struct buf_equals {
		bool operator()(const xv6::disk_buf::buf_t& b, dev_t dev, daddr_t sector) const {
			return dev == b.dev && sector == b.sector;
		}
	using buf_cache_t = xv6::static_cache<disk_buf::buf_t,buf_equals, buf_hash, CACHE_SIZE>;
	friend buf_cache_t;
	static buf_cache_t buf_cache;
	buf_t* _buf;

};


} /* namespace xv6 */

#endif /* XV6CPP_BUF_H_ */
