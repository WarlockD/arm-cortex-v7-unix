
#include "nuttxinode.h"
#include "bitmap.h"
#include <cassert>
#include <cstring>

#ifndef DEBUGASSERT
#define DEBUGASSERT(a) assert(a)
#endif

#define CONFIG_SEM_PREALLOCHOLDERS 20
#define getpid() (0) /* filler */
#define pid_t int16_t
namespace nuttx {
	inode *inode::g_root_inode = nullptr;
	int inode::dir_compare(const char *fname, const char *nname)
	{
	  if (!nname) return 1;
	  if (!fname)return -1;
	  for (;;)
		{
		  if(*nname=='\0'){
			  if (dir_end(*fname))
				  return 0; /* Yes.. return match */
			  else
				  return 1;/* No... return find name > node name */
		  }
		  else if (dir_end(*fname)){ /* At end of find name? */
			  return -1; /* Yes... return find name < node name */
			}
		  /* Check for non-matching characters */
		  else if (*fname > *nname)  return 1;
		  else if (*fname < *nname)  return -1;
		  else { fname++; nname++; }
		}
	  return 0; // never gets here
	}
	const char *inode::dir_nextname(const char *name)
	{
		while (*name && !dir_sep(*name)) name++;
		if (*name) name++; // skip over the '/'
		return name;
	}
	const char *inode::dir_basename(const char *name)
	{
		const char *basename = nullptr;
		for (;;) {
			name = dir_nextname(name);
			if (name == nullptr || *name == '\0') break;
			basename = name;
		}
		return basename;
	}
#ifdef CONFIG_PSEUDOFS_SOFTLINKS
static int _inode_linktarget(FAR struct inode *node,
                             FAR struct inode_search_s *desc)
{
  unsigned int count = 0;
  bool save;
  int ret = -ENOENT;

  DEBUGASSERT(desc != NULL && node != NULL);

  /* An infinite loop is avoided only by the loop count.
   *
   * REVISIT:  The ELOOP error should be reported to the application in that
   * case but there is no simple mechanism to do that.
   */

  save = desc->nofollow;
  while (INODE_IS_SOFTLINK(node))
    {
      FAR const char *link = (FAR const char *)node->u.i_link;

      /* Reset and reinitialize the search descriptor.  */

      RELEASE_SEARCH(desc);
      SETUP_SEARCH(desc, link, true);

      /* Look up inode associated with the target of the symbolic link */

      ret = _inode_search(desc);
      if (ret < 0)
        {
          break;
        }

      /* Limit the number of symbolic links that we pass through */

      if (++count > SYMLOOP_MAX)
        {
          ret = -ELOOP;
          break;
        }

      /* Set up for the next time through the loop */

      node = desc->node;
      DEBUGASSERT(node != NULL);
      desc->linktgt = link;
    }

  desc->nofollow = save;
  return ret;
}
#endif

#ifdef CONFIG_PSEUDOFS_SOFTLINKS
static int _inode_linktarget(FAR struct inode *node,
                             FAR struct inode_search_s *desc);
#endif







};
