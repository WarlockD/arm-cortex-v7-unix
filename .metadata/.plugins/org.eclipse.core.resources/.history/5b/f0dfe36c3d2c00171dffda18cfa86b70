#ifndef _LIST_HPP_
#define _LIST_HPP_

#include <cstdint>
#include <cstddef>
#include <functional>
#include <type_traits>
#include <list>
namespace sys {
	namespace priv {
		template<typename _Tp, typename _Res, typename _Class>
		auto get_field(_Tp&& obj, _Res _Class::* member) noexcept -> decltype(std::forward<_Tp>(obj).*std::declval<_Res _Class::*&>()) {
			return std::forward<_Tp>(obj).*member;
		}
#if 0
		template<typename T, typename FIELD>
		void slist_insert_head(slist_head<T>&head, T* elm, FIELD &&field) { //FT&& field){
			using entry_type = slist_entry<T>;;
			auto t = std::mem_fn(std::forward<FIELD>(field));
			t(*elm).sle_next = head.slh_first;
			//get_field(elm, std::forward<FIELD>(field)).sle_next = head.slh_first;
			head.slh_first = elm;
		}
#endif
	};

	template<typename T> struct slist_head;
	template<typename T> struct slist_entry;
	template<typename T, typename _Res, typename _Class,bool is_const=std::is_const<T>::value>
	struct iterator;
	template<typename T>
	struct slist_traits {
		using difference_type = ptrdiff_t;
		using iterator_category = std::forward_iterator_tag;
		using value_type = T;
		using pointer = T*;
		using reference = T&;
		using const_pointer = const T*;
		using const_reference = const T&;
		using entry_type = slist_entry<T>;
		using head_type = slist_head<T>;
	};

	template<typename T>
	struct slist_entry{
		using difference_type = typename slist_traits<T>::difference_type;
		using iterator_category = typename slist_traits<T>::iterator_category;
		using value_type =  typename slist_traits<T>::value_type;
		using pointer =  typename slist_traits<T>::pointer;
		using reference = typename slist_traits<T>::reference;;
		using const_pointer = typename slist_traits<T>::const_pointer;
		using const_reference = typename slist_traits<T>::const_reference;
		using entry_type = typename slist_traits<T>::entry_type;
		using head_type = typename slist_traits<T>::head_type;

		pointer sle_next;
		slist_entry() : sle_next(nullptr) {}
	};


	template<typename T, typename _Res, typename _Class,bool _is_const>
	struct slist_iterator  {
		using difference_type = typename slist_traits<T>::difference_type;
		using iterator_category = typename slist_traits<T>::iterator_category;
		using value_type =  typename slist_traits<T>::value_type;
		using pointer = typename std::conditional<_is_const, const T*, T*>::type;
		using reference = typename std::conditional<_is_const, const T&, T&>::type;
		using const_pointer = typename slist_traits<T>::const_pointer;
		using const_reference = typename slist_traits<T>::const_reference;
		using entry_type = typename slist_traits<T>::entry_type;
		using head_type = typename slist_traits<T>::head_type;
		using field_type = _Res _Class::*;
		using iterator =  slist_iterator<T,_Res,_Class,_is_const>;

		slist_iterator(pointer current, field_type field) noexcept :
			_current(current), _field(field) {}
		inline iterator operator++() noexcept {
			if(_current) _current = next();
			return iterator(*this);
		}
		inline iterator operator++(int) noexcept {
			iterator tmp(*this);
			if(_current) _current = next();
			return tmp;
		}
	      // Must downcast from _List_node_base to _List_node to get to _M_data.
	    reference operator*() const noexcept { return _current; }
	    pointer operator->() const noexcept { return _current; }
	    // do I need to test if the field pointers are equal?
	    bool operator==(const iterator& r) const { return _current == r._current; }
	    bool operator!=(const iterator& r) const { return _current != r._current; }
	private:
		pointer next() const { return _current.*_field; }
		pointer _current;
		field_type _field;
	};

	template<typename T>
	struct slist_head{
		using difference_type = typename slist_traits<T>::difference_type;
		using iterator_category = typename slist_traits<T>::iterator_category;
		using value_type =  typename slist_traits<T>::value_type;
		using pointer =  typename slist_traits<T>::pointer;
		using reference = typename slist_traits<T>::reference;;
		using const_pointer = typename slist_traits<T>::const_pointer;
		using const_reference = typename slist_traits<T>::const_reference;
		using entry_type = typename slist_traits<T>::entry_type;
		using head_type = typename slist_traits<T>::head_type;

		pointer slh_first;
		slist_head() : slh_first(nullptr) {}
		bool empty() const { return slh_first == nullptr; }
		pointer first() const { return slh_first; }
	};

	// helper, like a stupid mem_fn

	template<typename T, typename _Res, typename _Class>
	struct slist_foreach : public slist_traits<T> {
		using difference_type = typename slist_traits<T>::difference_type;
		using iterator_category = typename slist_traits<T>::iterator_category;
		using value_type =  typename slist_traits<T>::value_type;
		using pointer =  typename slist_traits<T>::pointer;
		using reference = typename slist_traits<T>::reference;;
		using const_pointer = typename slist_traits<T>::const_pointer;
		using const_reference = typename slist_traits<T>::const_reference;
		using entry_type = typename slist_traits<T>::entry_type;
		using head_type = typename slist_traits<T>::head_type;

		using field_type = _Res _Class::*;

		using iterator =  slist_iterator<T,_Res,_Class,false>;
		using const_iterator =  slist_iterator<T,_Res,_Class,true>;

		slist_foreach(head_type& head, field_type field) noexcept : _field(field),_from(head.slh_first) {}
		slist_foreach(pointer from, field_type field) noexcept :  _field(field),_from(from) {}
		iterator begin() { return iterator(_from,_field); }
		iterator end() { return iterator(nullptr,_field); }
		const_iterator begin() const { return const_iterator(_from,_field); }
		const_iterator end() const { return const_iterator(nullptr,_field); }
	protected:
		pointer _from;
		field_type _field;
	};
	template<typename T, typename U> constexpr size_t offsetOf(U T::*member)
	{
	    return (char*)&((T*)nullptr->*member) - (char*)nullptr;
	}
	namespace _oldc11 {
			template <typename T1, typename T2>
			struct offset_of_impl {
				static T2 object;
				static constexpr size_t offset(T1 T2::*member) {
					return size_t(&(offset_of_impl<T1, T2>::object.*member)) -
						   size_t(&offset_of_impl<T1, T2>::object);
				}
			};
			template <typename T1, typename T2>
			T2 offset_of_impl<T1, T2>::object;

			template <typename T1, typename T2>
			inline constexpr size_t offset_of(T1 T2::*member) {
				return offset_of_impl<T1, T2>::offset(member);
			}
		};
		template <typename T1, typename T2>
		inline size_t constexpr offset_of(T1 T2::*member) {
		    constexpr T2 object {};
		    return size_t(&(object.*member)) - size_t(&object);
		}

	template<class T, class _Res, class _Class>
	__attribute__((always_inline)) constexpr inline static slist_entry<T>& slist_field(T* obj, _Res _Class::* member) noexcept {
		//constexpr size_t off = offsetOf(member);
		return     obj->*member;
	}


	template<typename T, typename FT>
	__attribute__((always_inline)) constexpr inline static T*& slist_next(T* p, FT&& field)  {
		return slist_field(p,field).sle_next;
	}
	template<typename T, typename FT>
	__attribute__((always_inline)) constexpr inline static const T*& slist_next(const T* p, FT&& field)  {
		return slist_field(p,field).sle_next;
	}
	template<typename T>
	constexpr inline T* slist_first(slist_head<T>&head)  {
		return head.slh_first;
	}
	template<typename T>
	__attribute__((always_inline)) constexpr inline bool slist_empty(slist_head<T>&head)  {
		return head.slh_first == nullptr;
	}
	template<typename T,typename FT>
	inline void slist_insert_after(T* slistelm, T* elm,  FT&& field){
		slist_next(elm,field) = slist_next(slistelm,field);
		slist_next(slistelm,field) = elm;
	}
	template<typename T, typename FIELD>
	__attribute__((always_inline)) inline static void slist_insert_head(slist_head<T>&head, T* elm, FIELD &&field) { //FT&& field){
		slist_next(elm,field) = head.slh_first;
		head.slh_first = elm;
	}
	template<typename T,typename FT>
	inline void slist_remove_head(slist_head<T>&head,   FT&& field){
		if(head.slh_first !=nullptr)
			head.slh_first = slist_next(head.slh_first,field);
	}
	template<typename T,typename FT>
	inline void slist_remove_after(T* elm,   FT&& field){
		slist_next(elm,field) = slist_next(slist_next(elm,field),field);
	}
	template<typename T, typename FIELD>
	inline void slist_remove(slist_head<T>&head, T* elm, FIELD &&field) { //FT&& field){
		//QMD_SAVELINK(oldnext, (elm)->field.sle_next);
		slist_next(elm,field) = head.slh_first;
		head.slh_first = elm;
		if(head.first() == elm)
			slist_remove_head(head,field);
		else {
			T* curelm = head.first();
			while(slist_next(curelm,field) != elm)
				curelm = slist_next(curelm,field);
			slist_remove_after(curelm,field);
		}
		//TRASHIT(*oldnext);
	}


};













#endif
