/*===========================================================================
     _____        _____        _____        _____
 ___|    _|__  __|_    |__  __|__   |__  __| __  |__  ______
|    \  /  | ||    \      ||     |     ||  |/ /     ||___   |
|     \/   | ||     \     ||     \     ||     \     ||___   |
|__/\__/|__|_||__|\__\  __||__|\__\  __||__|\__\  __||______|
    |_____|      |_____|      |_____|      |_____|

--[Mark3 Realtime Platform]--------------------------------------------------

Copyright (c) 2012-2016 Funkenstein Software Consulting, all rights reserved.
See license.txt for more information
===========================================================================*/
/*!

    \file   scheduler.cpp

    \brief  Strict-Priority + Round-Robin thread scheduler implementation

*/

#include "kerneltypes.h"
#include "ll.h"
#include "scheduler.h"
#include "thread.h"
#include "threadport.h"
#include "kernel.h"

#define _CAN_HAS_DEBUG
//--[Autogenerated - Do Not Modify]------------------------------------------
#include "dbg_file_list.h"
#include "buffalogger.h"
#if defined(DBG_FILE)
# error "Debug logging file token already defined!  Bailing."
#else
# define DBG_FILE _DBG___KERNEL_SCHEDULER_CPP
#endif
//--[End Autogenerated content]----------------------------------------------

#include "kerneldebug.h"
volatile Thread *g_pclNext;      //!< Pointer to the currently-chosen next-running thread
Thread *g_pclCurrent;   //!< Pointer to the currently-running thread

//---------------------------------------------------------------------------
bool Scheduler::m_bEnabled;
bool Scheduler::m_bQueuedSchedule;

//---------------------------------------------------------------------------
ThreadList  Scheduler::m_clStopList;
ThreadList  Scheduler::m_aclPriorities[KERNEL_NUM_PRIORITIES];
PriorityMap Scheduler::m_clPrioMap;

//---------------------------------------------------------------------------
void Scheduler::Init() 
{
    for (int i = 0; i < KERNEL_NUM_PRIORITIES; i++)
    {
        m_aclPriorities[i].SetPriority(i);
        m_aclPriorities[i].SetMapPointer(&m_clPrioMap);
    }
    m_bQueuedSchedule = false;
}

//---------------------------------------------------------------------------
void Scheduler::Schedule()
{
    PRIO_TYPE uXPrio;

    uXPrio = m_clPrioMap.HighestPriority();

#if KERNEL_USE_IDLE_FUNC
    if (uXPrio == 0)
    {
        // There aren't any active threads at all - set g_pclNext to IDLE
        g_pclNext = Kernel::GetIdleThread();
    }
    else
#endif
    {
        // Priorities are one-indexed 
        uXPrio--;

        // Get the thread node at this priority.
        g_pclNext = (Thread*)( m_aclPriorities[uXPrio].GetHead() );
    }
    KERNEL_TRACE_1( "Next Thread: %d\n", (uint16_t)((Thread*)g_pclNext)->GetID() );

}

//---------------------------------------------------------------------------
void Scheduler::Add(Thread *pclThread_)
{
    m_aclPriorities[pclThread_->GetPriority()].Add(pclThread_);
}

//---------------------------------------------------------------------------
void Scheduler::Remove(Thread *pclThread_)
{
    m_aclPriorities[pclThread_->GetPriority()].Remove(pclThread_);
}

//---------------------------------------------------------------------------
bool Scheduler::SetScheduler(bool bEnable_)
{
    bool bRet ;
    CS_ENTER();
    bRet = m_bEnabled;
    m_bEnabled = bEnable_;
    // If there was a queued scheduler evevent, dequeue and trigger an
    // immediate Yield
    if (m_bEnabled && m_bQueuedSchedule)
    {
        m_bQueuedSchedule = false;
        Thread::Yield();
    }
    CS_EXIT();
    return bRet;
}
