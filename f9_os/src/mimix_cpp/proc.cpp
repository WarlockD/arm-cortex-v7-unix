/*
 * proc.cpp
 *
 *  Created on: May 11, 2017
 *      Author: Paul
 */

#include "proc.hpp"
#include <os\atomic.h>

/* Process numbers of some important processes */
#define MM_PROC_NR         0	/* process number of memory manager */
#define FS_PROC_NR         1	/* process number of file system */
#define INIT_PROC_NR       2	/* init -- the process that goes multiuser */
#define LOW_USER           2	/* first user not part of operating system */
/* The following error codes are generated by the kernel itself. */
#define E_BAD_DEST        -1	/* destination address illegal */
#define E_BAD_SRC         -2	/* source address illegal */
#define E_TRY_AGAIN       -3	/* can't send-- tables full */
#define E_OVERRUN         -4	/* interrupt for task that is not waiting */
#define E_BAD_BUF         -5	/* message buf outside caller's addr space */
#define E_TASK            -6	/* can't send to task */
#define E_NO_MESSAGE      -7	/* RECEIVE failed: no message present */
#define E_NO_PERM         -8	/* ordinary users can't send to tasks */
#define E_BAD_FCN         -9	/* only valid fcns are SEND, RECEIVE, BOTH */
#define E_BAD_ADDR       -10	/* bad address given to utility routine */
#define E_BAD_PROC       -11	/* bad proc number given to utility */


// notes for svc handler
void __attribute__ (( naked )) sv_call_handler(void)
{
    asm volatile(
      "movs r0, #4\t\n"
      "mov  r1, lr\t\n"
      "tst  r0, r1\t\n" /* Check EXC_RETURN[2] */
      "beq 1f\t\n"
      "mrs r0, psp\t\n"
      "ldr r1,=sv_call_handler_c\t\n"
      "bx r1\t\n"
      "1:mrs r0,msp\t\n"
      "ldr r1,=sv_call_handler_c\t\n"
      : /* no output */
      : /* no input */
      : "r0" /* clobber */
  );
}
sv_call_handler_c(unsigned int * hardfault_args)
{
    unsigned int stacked_r0;
    unsigned int stacked_r1;
    unsigned int stacked_r2;
    unsigned int stacked_r3;
    unsigned int stacked_r12;
    unsigned int stacked_lr;
    unsigned int stacked_pc;
    unsigned int stacked_psr;
    unsigned int svc_parameter;

    //Exception stack frame
    stacked_r0 = ((unsigned long) hardfault_args[0]);
    stacked_r1 = ((unsigned long) hardfault_args[1]);
    stacked_r2 = ((unsigned long) hardfault_args[2]);
    stacked_r3 = ((unsigned long) hardfault_args[3]);

    stacked_r12 = ((unsigned long) hardfault_args[4]);
    stacked_lr  = ((unsigned long) hardfault_args[5]);
    stacked_pc  = ((unsigned long) hardfault_args[6]);
    stacked_psr = ((unsigned long) hardfault_args[7]);

    svc_parameter = ((char *)stacked_pc)[-2]; /* would be LSB of PC is 1. */

    switch(svc_parameter){
    // each procesure call for the parameter
    }
}
namespace mimx {
	static proc idle_proc;
	void tq_list::run_task_queue(void * f){
		tq_list* l = reinterpret_cast<tq_list*>(f);
		l->run();
	}
	 tq_list tq_list::tq_immediate;
	 tq_list tq_list::tq_scheduler;
	 tq_list tq_list::tq_disk;
	 static proc HARDWARE;
	 proc proc::procs[NR_TASKS + NR_PROCS];	/* process table */
	 proc * proc::pproc_addr[NR_TASKS + NR_PROCS];
	 proc::hash_list_t   proc::_hash; // hash list by pids
	 proc::proc_queue_t proc::_tasks; // highest prioirty
	 proc::proc_queue_t proc::_server; // secound highest prioirty
	 proc::proc_queue_t proc::_user; // all user process highest prioirty
	proc*   proc::prev_proc=nullptr;
	proc* 	proc::cur_proc=nullptr;
	proc* 	proc::bill_ptr=nullptr;
	 proc::proc_queue_t& proc::next_proc() {
		 if(!_tasks.empty()) return _tasks;
		 else if(!_server.empty()) return _server;
		 else return _user;
	}

proc::proc() {
	// TODO Auto-generated constructor stub

}

proc::~proc() {
	// TODO Auto-generated destructor stub
}
int proc::sys_call(
	int function,			/* SEND, RECEIVE, or BOTH */
	int caller,			/* who is making this call */
	int src_dst,			/* source to receive from or dest to send to */
	message *m_ptr			/* pointer to message */
	){
	/* The only system calls that exist in MINIX are sending and receiving
	 * messages.  These are done by trapping to the kernel with an INT instruction.
	 * The trap is caught and sys_call() is called to send or receive a message (or
	 * both).
	 */

	  int n;

	  /* Check for bad system call parameters. */
	  proc* caller_ptr = lookup(caller);
	  proc* src_ptr = nullptr;
	  /* Check for bad system call parameters. */
	  if(src_dst != ANY && (src_ptr = lookup(src_dst))==nullptr) return  E_BAD_SRC;
	  if (function != BOTH && caller_ptr->_qprio != sched_priority::user) return E_NO_PERM;	/* users only do BOTH */

	  /* The parameters are ok. Do the call. */
	  if (function & SEND) {
		n = mini_send(caller_ptr, src_ptr, m_ptr);	/* func = SEND or BOTH */
		if(n != 0) return n;
	  }
	  if (function & RECEIVE) {
		n = mini_receive(caller_ptr, src_ptr, m_ptr);      /* func = RECEIVE or BOTH */
	  }
	  return n;
}

int proc::mini_send(proc* caller, proc*  dst,message* m_ptr){
	/* Send a message from 'caller' to 'dest'.  If 'dest' is blocked waiting for
		 * this message, copy the message to it and unblock 'dest'.  If 'dest' is not
		 * waiting at all, or is waiting for another source, queue 'caller'.
		 */

		 // register struct proc *caller_ptr, *dest_ptr, *next_ptr;
		//  vir_bytes vb;			/* message buffer pointer as vir_bytes */
		//  vir_clicks vlo, vhi;		/* virtual clicks containing message to send */
		//  vir_clicks len;		/* length of data segment in clicks */
		if(dst == nullptr) return E_BAD_DEST; // ; // ANY
		if(dst == nullptr)return  E_BAD_DEST;

		  /* User processes are only allowed to send to FS and MM.  Check for this. */
		//  if (caller >= LOW_USER && (dest != FS_PROC_NR && dest != MM_PROC_NR))
		//	return(E_BAD_DEST);
		// why?

		  if (dst->_flags & SLOT_FREE) return (E_BAD_DEST);	/* dead dest */


		  /* Check to see if 'dest' is blocked waiting for this message. */
		  if ((dst->_flags & RECEIVING) && (dst->_getfrom == ANY || dst->_getfrom == caller->_nr) ) {
			/* Destination is indeed waiting for this message. */
			  dst->_messbuf = m_ptr;
			  dst->_flags &= ~RECEIVING;	/* deblock destination */
			if (dst->_flags == 0) dst->ready();
		  } else {
			/* Destination is not waiting.  Block and queue caller. */
			if (caller == &idle_proc) return E_OVERRUN;
			caller->_messbuf = m_ptr;
			caller->_flags |= SENDING;
			caller->unready();
			/* Process is now blocked.  Put in on the destination's queue. */
			dst->_callerq.push_front(caller);
		  }
		  return 0;
}
int proc::mini_receive(proc* caller, proc* src, message *m_ptr){
	/* A process or task wants to get a message.  If one is already queued,
		 * acquire it and deblock the sender.  If no message from the desired source
		 * is available, block the caller.  No need to check parameters for validity.
		 * Users calls are always sendrec(), and mini_send() has checked already.
		 * Calls from the tasks, MM, and FS are trusted.
		 */
		 // register struct proc *caller_ptr, *sender_ptr, *prev_ptr;
		 // int sender;

		  //caller_ptr = proc_addr(caller);	/* pointer to caller's proc structure */

		  /* Check to see if a message from desired source is already available. */
		for(auto it = caller->_callerq.begin(); it != caller->_callerq.end(); ) {
			proc* sender = &(*it);
			if(src == nullptr || src == sender) {
				// copy the
				sender->_messbuf = m_ptr;
				sender->_flags &= ~SENDING;/* deblock sender */
				if(sender->_flags == 0) sender->ready();
				it = caller->_callerq.erase(it);
				return 0; // done
			} else ++it;
		}
		  /* No suitable message is available.  Block the process trying to receive. */
		caller->_getfrom = src->_nr;
		caller->_messbuf = m_ptr;
		caller->_flags|= RECEIVING;
		caller->unready();


		  /* If MM has just blocked and there are kernel signals pending, now is the
		   * time to tell MM about them, since it will be able to accept the message.
		   */
		//  if (sig_procs > 0 && caller == MM_PROC_NR && src == ANY) inform(MM_PROC_NR);
		  return 0;
}

int proc::mini_notify(int dst){
	return 0;
}
void proc::interrupt(message* m_ptr) {
	/* An interrupt has occurred.  Schedule the task that handles it. */

	  int i, n, old_map;

	#ifdef i8088
	  /* Re-enable the 8259A interrupt controller. */
	  port_out(INT_CTL, ENABLE);	/* this re-enables the 8259A controller chip */
	  if (pc_at) port_out(INT2_CTL, ENABLE);	/* re-enable second 8259A */
	#endif

	  /* Try to send the interrupt message to the indicated task. */
	  int this_bit = 1 << (-_nr);
	  if (mini_send(&HARDWARE, this, m_ptr) != 0) {
		/* The message could not be sent to the task; it was not waiting. */
		old_map = busy_map;	/* save original map of busy tasks */
		if (task == CLOCK) {
			lost_ticks++;
		} else {
			busy_map |= this_bit;		/* mark task as busy */
			task_mess[-task] = m_ptr;	/* record message pointer */
		}
	  } else {
		/* Hardware interrupt was successfully sent as a message. */
		busy_map &= ~this_bit;	/* turn off the bit in case it was on */
		old_map = busy_map;
	  }

	  /* See if any tasks that were previously busy are now listening for msgs. */
	  if (old_map != 0) {
		for (i = 2; i <= NR_TASKS; i++) {
			/* Check each task looking for one with a pending interrupt. */
			if ( (old_map>>i) & 1) {
				/* Task 'i' has a pending interrupt. */
				n = mini_send(HARDWARE, -i, task_mess[i]);
				if (n == OK) busy_map &= ~(1 << i);
			}
		}
	  }

	  /* If a task has just been readied and a user is running, run the task. */
	  if (rdy_head[TASK_Q] != NIL_PROC && (cur_proc >= 0 || cur_proc == IDLE))
		pick_proc();
}
void proc::unready() {
	ARM::simple_irq_lock lock; // for now, want to switch to base pri
	auto& q = get_attached_queue();
	switch(_state) {
	case proc_state::running:
		q.remove(this); // attach to the end
		break;
	case proc_state::waiting:
		_waiting.remove(this);
		break;
	case proc_state::zombie: return; // if we are a zombie already don't need to do anything
	default:
		break;
	}
}
void proc::ready() {
	ARM::simple_irq_lock lock; // for now, want to switch to base pri
	/* Add 'rp' to the end of one of the queues of runnable processes. Three
	 * queues are maintained:
	 *   TASK_Q   - (highest priority) for runnable tasks
	 *   SERVER_Q - (middle priority) for MM and FS only
	 *   USER_Q   - (lowest priority) for user processes
	 */
	auto& q = get_attached_queue();
	switch(_state) {
	case proc_state::running:
		q.remove(this); // attach to the end
		break;
	case proc_state::waiting:
		_waiting.remove(this);
		break;
	case proc_state::zombie:
	default:
		break;
	}
	_state = proc_state::running;
	q.push_back(this);
}

void proc::pick_proc(){
	 /* Decide who to run now. */

	 //  register int q;		/* which queue to use */
	   proc::proc_queue_t& list = next_proc();
	   /* Set 'cur_proc' and 'proc_ptr'. If system is idle, set 'cur_proc' to a
	    * special value (IDLE), and set 'proc_ptr' to point to an unused proc table
	    * slot, namely, that of task -1 (HARDWARE), so save() will have somewhere to
	    * deposit the registers when a interrupt occurs on an idle machine.
	    * Record previous process so that when clock tick happens, the clock task
	    * can find out who was running just before it began to run.  (While the
	    * clock task is running, 'cur_proc' = CLOCKTASK. In addition, set 'bill_ptr'
	    * to always point to the process to be billed for CPU time.
	    */
	   prev_proc = cur_proc;
	   if(list.empty()) { // we are idle
		   cur_proc = &idle_proc;
		   bill_ptr = cur_proc;
	   }else {
	 	/* Someone is runnable. */
		   cur_proc = list.first_entry();
		   bill_ptr = cur_proc; // if (cur_proc >= LOW_USER)
	   }
}

// such a simple schedular
void proc::sched(){
	ARM::simple_irq_lock lock;
	if(_user.empty())  return; // no tasks, don't do shit
	proc* head = _user.pop_front();
	_user.push_back(head); // just move to the end, round_robin!
	pick_proc();
}



}; /* namespace mimx */
