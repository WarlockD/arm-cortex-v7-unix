/*
 * proc.cpp
 *
 *  Created on: May 11, 2017
 *      Author: Paul
 */

#include "proc.hpp"
#include <os\atomic.h>
#include <os\irq.hpp>
#define _SYSTEM
#include <errno.h>

#define OK 0
#if 0
/* The following error codes are generated by the kernel itself. */
#define E_BAD_DEST        -1	/* destination address illegal */
#define E_BAD_SRC         -2	/* source address illegal */
#define E_TRY_AGAIN       -3	/* can't send-- tables full */
#define E_OVERRUN         -4	/* interrupt for task that is not waiting */
#define E_BAD_BUF         -5	/* message buf outside caller's addr space */
#define E_TASK            -6	/* can't send to task */
#define E_NO_MESSAGE      -7	/* RECEIVE failed: no message present */
#define E_NO_PERM         -8	/* ordinary users can't send to tasks */
#define E_BAD_FCN         -9	/* only valid fcns are SEND, RECEIVE, BOTH */
#define E_BAD_ADDR       -10	/* bad address given to utility routine */
#define E_BAD_PROC       -11	/* bad proc number given to utility */
#endif

//globals, FIX
namespace mimx{
	/* Global variables used in the kernel. */
	/* Low level interrupt communications. */
	proc *held_head=nullptr;	/* head of queue of held-up interrupts */
	proc *held_tail=nullptr;	/* tail of queue of held-up interrupts */
	unsigned char k_reenter=0;	/* kernel reentry count (entry count less 1)*/
};
extern "C" mimx::stackframe_s* _syscall(int function, int src_dest, mimx::message* m_ptr, mimx::stackframe_s* stack){
	mimx::proc::proc_ptr->p_reg = stack;
	stack->set_r0(mimx::proc::sys_call(function,src_dest,m_ptr));
	if(mimx::held_head != nullptr) mimx::proc::unhold(); // this is rare so overhead is acceptable
	return mimx::proc::proc_ptr->p_reg;
}
#if 0
extern "C" void __attribute__ (( naked ))SVC_Handler() {
    // Core with FPU (cortex-M4F)
    asm volatile (
        "    CPSID     I                 \n" // Prevent interruption during syscall
        "    MRS       R3, PSP           \n" // PSP is process stack pointer
      //  "    TST       LR, #0x10         \n" // exc_return[4]=0? (it means that current process
      //  "    IT        EQ                \n" // has active floating point context)
      //  "    VSTMDBEQ  R3!, {S16-S31}    \n" // if so - save it.
        "    STMDB     R3!, {R4-R11, LR} \n" // save remaining regs r4-11 and LR on process stack

        // At this point, entire context of process has been saved
        "    LDR     R1, =_syscall  \n"   // call os_context_switch_hook();
        "    BLX     R1                \n"

        // R0 is new process SP;
        "    LDMIA     R0!, {R4-R11, LR} \n" // Restore r4-11 and LR from new process stack
    //    "    TST       LR, #0x10         \n" // exc_return[4]=0? (it means that new process
    //    "    IT        EQ                \n" // has active floating point context)
    //    "    VLDMIAEQ  R0!, {S16-S31}    \n" // if so - restore it.
        "    MSR       PSP, R0           \n" // Load PSP with new process SP
        "    CPSIE     I                 \n"
        "    BX        LR                \n" // Return to saved exc_return. Exception return will restore remaining context
        : :
    );
}
#endif
#if 0

// notes for svc handler
void __attribute__ (( naked )) sv_call_handler(void)
{
    asm volatile(
      "movs r0, #4\t\n"
      "mov  r1, lr\t\n"
      "tst  r0, r1\t\n" /* Check EXC_RETURN[2] */
      "beq 1f\t\n"
      "mrs r0, psp\t\n"
      "ldr r1,=sv_call_handler_c\t\n"
      "bx r1\t\n"
      "1:mrs r0,msp\t\n"
      "ldr r1,=sv_call_handler_c\t\n"
      : /* no output */
      : /* no input */
      : "r0" /* clobber */
  );
}
sv_call_handler_c(unsigned int * hardfault_args)
{
    unsigned int stacked_r0;
    unsigned int stacked_r1;
    unsigned int stacked_r2;
    unsigned int stacked_r3;
    unsigned int stacked_r12;
    unsigned int stacked_lr;
    unsigned int stacked_pc;
    unsigned int stacked_psr;
    unsigned int svc_parameter;

    //Exception stack frame
    stacked_r0 = ((unsigned long) hardfault_args[0]);
    stacked_r1 = ((unsigned long) hardfault_args[1]);
    stacked_r2 = ((unsigned long) hardfault_args[2]);
    stacked_r3 = ((unsigned long) hardfault_args[3]);

    stacked_r12 = ((unsigned long) hardfault_args[4]);
    stacked_lr  = ((unsigned long) hardfault_args[5]);
    stacked_pc  = ((unsigned long) hardfault_args[6]);
    stacked_psr = ((unsigned long) hardfault_args[7]);

    svc_parameter = ((char *)stacked_pc)[-2]; /* would be LSB of PC is 1. */

    switch(svc_parameter){
    // each procesure call for the parameter
    }
}
#endif

namespace mimx {



	/* Process table.  Here to stop too many things having to include proc.h. */
	//proc *proc_ptr;	/* pointer to currently running process */

	/* Signals. */
	int sig_procs;		/* number of procs with p_pending != 0 */

	/* Clocks and timers */
	time_t realtime;	/* real time clock */
	time_t lost_ticks;		/* incremented when clock int can't send mess*/

	/* Processes, signals, and messages. */
	pid_t cur_proc;		/* current process */
	pid_t prev_proc;		/* previous process */
//	size_t sig_procs;		/* number of procs with p_pending != 0 */
	message int_mess;	/* interrupt routines build message here */


	/* The kernel and task stacks. */
	struct t_stack {
	  int stk[1024/sizeof(int)];
	} t_stack[NR_TASKS - 1];	/* task stacks; task = -1 never really runs */

	char k_stack[1024];	/* The kernel stack. */

	proc *proc::proc_ptr=nullptr;	/* &proc[cur_proc] */
	proc *proc::bill_ptr=nullptr;	/* ptr to process to bill for clock ticks */
	proc *proc::rdy_head[NQ];	/* pointers to ready list headers */
	proc *proc::rdy_tail[NQ];	/* pointers to ready list tails */
	bitops::bitmap_t<NR_TASKS+1> busy_map;		/* bit map of busy tasks */
	message *proc::task_mess[NR_TASKS+1];	/* ptrs to messages for busy tasks */
	proc *proc::pproc_addr[NR_TASKS + NR_PROCS];
	volatile bool proc::switching = false;
	proc proc::procs[NR_TASKS+NR_PROCS];
  	//constexpr static inline proc* proc_addr(pid_t n) { return &proc::procs[NR_TASKS + n]; }

	#define CopyMess(s,sp,sm,dp,dm) cp_mess(s,sp,sm,dp,dm)



	/*===========================================================================*
	 *				interrupt				     *
	 *===========================================================================*/
	void proc::interrupt(int task)
	//int task;			/* number of task to be started */
	{
	/* An interrupt has occurred.  Schedule the task that handles it. */

	  proc *rp;	/* pointer to task's proc entry */

	  rp = proc_addr(task);

	  /* If this call would compete with other process-switching functions, put
	   * it on the 'held' queue to be flushed at the next non-competing restart().
	   * The competing conditions are:
	   * (1) k_reenter == (typeof k_reenter) -1:
	   *     Call from the task level, typically from an output interrupt
	   *     routine.  An interrupt handler might reenter interrupt().  Rare,
	   *     so not worth special treatment.
	   * (2) k_reenter > 0:
	   *     Call from a nested interrupt handler.  A previous interrupt handler
	   *     might be inside interrupt() or sys_call().
	   * (3) switching != 0:
	   *     Some process-switching function other than interrupt() is being
	   *     called from the task level, typically sched() from CLOCK.  An
	   *     interrupt handler might call interrupt and pass the k_reenter test.
	   */
	  if (k_reenter != 0 || switching) {
		  ARM::irq_disable();
		if (!rp->p_int_held) {
			rp->p_int_held = true;
			if (held_head != NIL_PROC)
				held_tail->p_nextheld = rp;
			else
				held_head = rp;
			held_tail = rp;
			rp->p_nextheld = NIL_PROC;
		}
		 ARM::irq_enable();
		return;
	  }
	  switching = true;

	  /* If task is not waiting for an interrupt, record the blockage. */
	  if ( (rp->p_flags & (PSTATE::RECEIVING | PSTATE::SENDING)) != PSTATE::RECEIVING ||
	      !isrxhardware(rp->p_getfrom)) {
		rp->p_int_blocked = true;
		switching = false;
		return;
	  }

	  /* Destination is waiting for an interrupt.
	   * Send it a message with source HARDWARE and type HARD_INT.
	   * No more information can be reliably provided since interrupt messages
	   * are not queued.
	   */
	  rp->p_messbuf->m_source = HARDWARE;
	  rp->p_messbuf->m_type = MSG::HARD_INT;
	  rp->p_flags &= ~PSTATE::RECEIVING;
	  rp->p_int_blocked = false;

	  rp->_ready();
	  switching = false;
	}

	/*===========================================================================*
	 *				sys_call				     *
	 *===========================================================================*/
	int proc::sys_call(int function, int src_dest, message* m_ptr)
	//int function;			/* SEND, RECEIVE, or BOTH */
	//int src_dest;			/* source to receive from or dest to send to */
	//message *m_ptr;			/* pointer to message */
	{
	/* The only system calls that exist in MINIX are sending and receiving
	 * messages.  These are done by trapping to the kernel with an INT instruction.
	 * The trap is caught and sys_call() is called to send or receive a message
	 * (or both). The caller is always given by proc_ptr.
	 */

	  proc *rp;
	  int n;

	  /* Check for bad system call parameters. */
	  if (!isoksrc_dest(src_dest)) return(E_BAD_DEST);
	  rp = proc_ptr;

	  if (rp->isuser() && function != BOTH) return(E_NO_PERM);

	  /* The parameters are ok. Do the call. */
	  if (function & SEND) {
		/* Function = SEND or BOTH. */
		n = rp->_mini_send(src_dest, m_ptr);
		if (function == SEND || n != OK)
			return(n);	/* done, or SEND failed */
	  }

	  /* Function = RECEIVE or BOTH.
	   * We have checked user calls are BOTH, and trust 'function' otherwise.
	   */
	  return (rp->_mini_rec(src_dest, m_ptr));
	}
	/*==========================================================================*
	 *				cp_mess					    *
	 *==========================================================================*/
	void proc::cp_mess(int src,  proc *src_p, message *src_m,  proc *dst_p, message *dst_m)
	{
	  /* convert virtual address to physical address */
	  /* The caller has already checked if all addresses are within bounds */

	  src_m = (message *)((char *)src_m + (((phys_bytes)src_p->p_map[D].mem_phys
					- src_p->p_map[D].mem_vir) << CLICK_SHIFT));
	  dst_m = (message *)((char *)dst_m + (((phys_bytes)dst_p->p_map[D].mem_phys
					- dst_p->p_map[D].mem_vir) << CLICK_SHIFT));
	#ifdef NEEDFSTRUCOPY
	  phys_copy(src_m,dst_m,(phys_bytes) sizeof(message));
	#else
	  *dst_m = *src_m;
	#endif
	  dst_m->m_source = src;
	}

	/*===========================================================================*
	 *				mini_send				     *
	 *===========================================================================*/
	int proc::_mini_send(int dest, message *m_ptr)
	//register struct proc *caller_ptr;	/* who is trying to send a message? */
	//int dest;			/* to whom is message being sent? */
	//message *m_ptr;			/* pointer to message buffer */
	{
	/* Send a message from 'caller_ptr' to 'dest'. If 'dest' is blocked waiting
	 * for this message, copy the message to it and unblock 'dest'. If 'dest' is
	 * not waiting at all, or is waiting for another source, queue 'caller_ptr'.
	 */
	//	 proc *caller_ptr = this; // just for now

	  register struct proc *dest_ptr, *next_ptr;
	  vir_bytes vb;			/* message buffer pointer as vir_bytes */
	  vir_clicks vlo, vhi;		/* virtual clicks containing message to send */

	  /* User processes are only allowed to send to FS and MM.  Check for this. */
	  if (isuser() && !issysentn(dest)) return(E_BAD_DEST);
	  dest_ptr = proc_addr(dest);	/* pointer to destination's proc entry */
	  if (dest_ptr->isempty()) return(E_BAD_DEST);	/* dead dest */

	#if ALLOW_GAP_MESSAGES
	  /* This check allows a message to be anywhere in data or stack or gap.
	   * It will have to be made more elaborate later for machines which
	   * don't have the gap mapped.
	   */
	  vb = (vir_bytes) m_ptr;
	  vlo = vb >> CLICK_SHIFT;	/* vir click for bottom of message */
	  vhi = (vb + MESS_SIZE - 1) >> CLICK_SHIFT;	/* vir click for top of msg */
	  if (vlo < caller_ptr->p_map[D].mem_vir || vlo > vhi ||
	      vhi >= caller_ptr->p_map[S].mem_vir + caller_ptr->p_map[S].mem_len)
	        return(EFAULT);
	#else
	  /* Check for messages wrapping around top of memory or outside data seg. */
	  vb = (vir_bytes) m_ptr;
	  vlo = vb >> CLICK_SHIFT;	/* vir click for bottom of message */
	  vhi = (vb + MESS_SIZE - 1) >> CLICK_SHIFT;	/* vir click for top of msg */
	  if (vhi < vlo ||
	      vhi - this->p_map[D].mem_vir >= this->p_map[D].mem_len)
		return(EFAULT);
	#endif

	  /* Check for deadlock by 'caller_ptr' and 'dest' sending to each other. */
	  if(dest_ptr->p_flags % PSTATE::SENDING) {
		next_ptr = proc_addr(dest_ptr->p_sendto);
		while (true) {
			if (next_ptr == this) return(ELOCKED);
			if (next_ptr->p_flags % PSTATE::SENDING)
				next_ptr = proc_addr(next_ptr->p_sendto);
			else
				break;
		}
	  }

	  /* Check to see if 'dest' is blocked waiting for this message. */
	  if ( (dest_ptr->p_flags & (PSTATE::RECEIVING | PSTATE::SENDING)) == PSTATE::RECEIVING &&
	       (dest_ptr->p_getfrom == ANY ||
	        dest_ptr->p_getfrom == this->proc_number())) {
		/* Destination is indeed waiting for this message. */
		CopyMess(this->proc_number(), this, m_ptr, dest_ptr, dest_ptr->p_messbuf);
		dest_ptr->p_flags &= ~PSTATE::RECEIVING;	/* deblock destination */
		if (dest_ptr->p_flags == PSTATE::UNBLOCKED) dest_ptr->_ready();
	  } else {
		/* Destination is not waiting.  Block and queue caller. */
		  this->p_messbuf = m_ptr;
		if (this->p_flags == PSTATE::UNBLOCKED) this->unready();
		this->p_flags |= PSTATE::SENDING;
		this->p_sendto= dest;

		/* Process is now blocked.  Put in on the destination's queue. */
		if ( (next_ptr = dest_ptr->p_callerq) == NIL_PROC)
			dest_ptr->p_callerq = this;
		else {
			while (next_ptr->p_sendlink != NIL_PROC)
				next_ptr = next_ptr->p_sendlink;
			next_ptr->p_sendlink = this;
		}
		this->p_sendlink = NIL_PROC;
	  }
	  return(OK);
	}

	/*===========================================================================*
	 *				mini_rec				     *
	 *===========================================================================*/
	int proc::_mini_rec(int src, message * m_ptr)
	//register struct proc *caller_ptr;	/* process trying to get message */
	//int src;			/* which message source is wanted (or ANY) */
	//message *m_ptr;			/* pointer to message buffer */
	{
	/* A process or task wants to get a message.  If one is already queued,
	 * acquire it and deblock the sender.  If no message from the desired source
	 * is available, block the caller.  No need to check parameters for validity.
	 * Users calls are always sendrec(), and mini_send() has checked already.
	 * Calls from the tasks, MM, and FS are trusted.
	 */

	   proc *sender_ptr;
	  proc *previous_ptr;

	  /* Check to see if a message from desired source is already available. */
	  if (!(this->p_flags % PSTATE::SENDING)) {
		/* Check caller queue. */
	    for (sender_ptr = this->p_callerq; sender_ptr != NIL_PROC;
		 previous_ptr = sender_ptr, sender_ptr = sender_ptr->p_sendlink) {
		if (src == ANY || src == sender_ptr->proc_number()) {
			/* An acceptable message has been found. */
			CopyMess(sender_ptr->proc_number(), sender_ptr,
				 sender_ptr->p_messbuf, this, m_ptr);
			if (sender_ptr == this->p_callerq)
				this->p_callerq = sender_ptr->p_sendlink;
			else
				previous_ptr->p_sendlink = sender_ptr->p_sendlink;
			if ((sender_ptr->p_flags &= ~PSTATE::SENDING) == PSTATE::UNBLOCKED)
				sender_ptr->ready();	/* deblock sender */
			return(OK);
		}
	    }

	    /* Check for blocked interrupt. */
	    if (this->p_int_blocked && isrxhardware(src)) {
		m_ptr->m_source = HARDWARE;
		m_ptr->m_type = HARD_INT;
		this->p_int_blocked = false;
		return(OK);
	    }
	  }

	  /* No suitable message is available.  Block the process trying to receive. */
	  this->p_getfrom = src;
	  this->p_messbuf = m_ptr;
	  if (this->p_flags == PSTATE::UNBLOCKED) this->unready();
	  this->p_flags |= PSTATE::RECEIVING;

	  /* If MM has just blocked and there are kernel signals pending, now is the
	   * time to tell MM about them, since it will be able to accept the message.
	   */
	  if (sig_procs > 0 && this->proc_number() == MM_PROC_NR && src == ANY)
		inform();
	  return(OK);
	}
	/*===========================================================================*
	 *				pick_proc				     *
	 *===========================================================================*/
	void proc::pick_proc()
	{
	/* Decide who to run now.  A new process is selected by setting 'proc_ptr'.
	 * When a fresh user (or idle) process is selected, record it in 'bill_ptr',
	 * so the clock task can tell who to bill for system time.
	 */

	  proc *rp;	/* process to run */

	  if ( (rp = rdy_head[TASK_Q]) != NIL_PROC) {
		proc_ptr = rp;
		return;
	  }
	  if ( (rp = rdy_head[SERVER_Q]) != NIL_PROC) {
		proc_ptr = rp;
		return;
	  }
	  if ( (rp = rdy_head[USER_Q]) != NIL_PROC) {
		proc_ptr = rp;
		bill_ptr = rp;
		return;
	  }
	  /* No one is ready.  Run the idle task.  The idle task might be made an
	   * always-ready user task to avoid this special case.
	   */
	  bill_ptr = proc_ptr = proc_addr(IDLE);
	}

	/*===========================================================================*
	 *				ready					     *
	 *===========================================================================*/
	void proc::_ready()
	//register struct proc *rp;	/* this process is now runnable */
	{
	/* Add 'rp' to the end of one of the queues of runnable processes. Three
	 * queues are maintained:
	 *   TASK_Q   - (highest priority) for runnable tasks
	 *   SERVER_Q - (middle priority) for MM and FS only
	 *   USER_Q   - (lowest priority) for user processes
	 */

	  if (this->istask()) {
		if (rdy_head[TASK_Q] != NIL_PROC)
			/* Add to tail of nonempty queue. */
			rdy_tail[TASK_Q]->p_nextready = this;
		else {
			proc_ptr =		/* run fresh task next */
			rdy_head[TASK_Q] = this;	/* add to empty queue */
		}
		rdy_tail[TASK_Q] = this;
		this->p_nextready = NIL_PROC;	/* new entry has no successor */
		return;
	  }
	  if (this->isserv()) {		/* others are similar */
		if (rdy_head[SERVER_Q] != NIL_PROC)
			rdy_tail[SERVER_Q]->p_nextready = this;
		else
			rdy_head[SERVER_Q] = this;
		rdy_tail[SERVER_Q] = this;
		this->p_nextready = NIL_PROC;
		return;
	  }
	  /* Add user process to the front of the queue.  (Is a bit fairer to I/O
	   * bound processes.)
	   */
	  if (rdy_head[USER_Q] == NIL_PROC)
		rdy_tail[USER_Q] = this;
	  this->p_nextready = rdy_head[USER_Q];
	  rdy_head[USER_Q] = this;
	}
	/*===========================================================================*
	 *				unready					     *
	 *===========================================================================*/
	void proc::_unready()
	//register struct proc *rp;	/* this process is no longer runnable */
	{
	/* A process has blocked. */

	  proc *xp;
	  proc **qtail;  /* TASK_Q, SERVER_Q, or USER_Q rdy_tail */

	  if (istask()) {
		/* task stack still ok? */
		if (*this->p_stguard != STACK_GUARD)
			panic("stack overrun by task", this->proc_number());

		if ( (xp = rdy_head[TASK_Q]) == NIL_PROC) return;
		if (xp == this) {
			/* Remove head of queue */
			rdy_head[TASK_Q] = xp->p_nextready;
			if (this == proc_ptr) pick_proc();
			return;
		}
		qtail = &rdy_tail[TASK_Q];
	  }
	  else if (isserv()) {
		if ( (xp = rdy_head[SERVER_Q]) == NIL_PROC) return;
		if (xp == this) {
			rdy_head[SERVER_Q] = xp->p_nextready;
			if (this == proc_ptr) pick_proc();
			return;
		}
		qtail = &rdy_tail[SERVER_Q];
	  } else {
		if ( (xp = rdy_head[USER_Q]) == NIL_PROC) return;
		if (xp == this) {
			rdy_head[USER_Q] = xp->p_nextready;
			if (this == proc_ptr) pick_proc();
			return;
		}
		qtail = &rdy_tail[USER_Q];
	  }

	  /* Search body of queue.  A process can be made unready even if it is
	   * not running by being sent a signal that kills it.
	   */
	  while (xp->p_nextready != this)
		if ( (xp = xp->p_nextready) == NIL_PROC) return;
	  xp->p_nextready = xp->p_nextready->p_nextready;
	  if (*qtail == this) *qtail = xp;
	}

	void proc::_sched() {
		/* The current process has run too long.  If another low priority (user)
		 * process is runnable, put the current process on the end of the user queue,
		 * possibly promoting another user to head of the queue.
		 */

		  if (rdy_head[USER_Q] == NIL_PROC) return;

		  /* One or more user processes queued. */
		  rdy_tail[USER_Q]->p_nextready = rdy_head[USER_Q];
		  rdy_tail[USER_Q] = rdy_head[USER_Q];
		  rdy_head[USER_Q] = rdy_head[USER_Q]->p_nextready;
		  rdy_tail[USER_Q]->p_nextready = NIL_PROC;
		  pick_proc();
	}
	void proc::unhold() {
		/* Flush any held-up interrupts.  k_reenter must be 0.  held_head must not
		 * be NIL_PROC.  Interrupts must be disabled.  They will be enabled but will
		 * be disabled when this returns.
		 */

		  proc *rp;	/* current head of held queue */

		  if (switching) return;
		  rp = held_head;
		  do {
			if ( (held_head = rp->p_nextheld) == NIL_PROC) held_tail = NIL_PROC;
			rp->p_int_held = false;
			ARM::irq_disable(); /* reduce latency; held queue may change! */
			interrupt(rp->proc_number());
			ARM::irq_enable(); /* protect the held queue again */
		  }
		  while ( (rp = held_head) != NIL_PROC);
	}
}; /* namespace mimx */
